/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
/**
 * An enum which defines the registration lifetime policies.
 */
(function (Lifetime) {
    /**
     * A single instance is created and shared among all consumers.
     */
    Lifetime[Lifetime["Singleton"] = 0] = "Singleton";
    /**
     * A new instance is created each time one is requested.
     */
    Lifetime[Lifetime["Transient"] = 1] = "Transient";
})(exports.Lifetime || (exports.Lifetime = {}));
var Lifetime = exports.Lifetime;
/**
 * A run-time token object which holds compile-time type information.
 */
var Token = (function () {
    /**
     * Construct a new token object.
     *
     * @param name - A human readable name for the token.
     */
    function Token(name) {
        this._name = name;
    }
    Object.defineProperty(Token.prototype, "name", {
        /**
         * Get the human readable name for the token.
         *
         * #### Note
         * This is a read-only property.
         */
        get: function () {
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    return Token;
})();
exports.Token = Token;
/**
 * A lightweight dependency injection container.
 */
var Container = (function () {
    function Container() {
        this._registry = createRegistry();
    }
    /**
     * Test whether a token is registered with the container.
     *
     * @param token - The run-time type token of interest.
     *
     * @returns `true` if the token is registered, `false` otherwise.
     */
    Container.prototype.isRegistered = function (token) {
        return this._registry.has(token);
    };
    /**
     * Register a type mapping for the specified token.
     *
     * @param token - The run-time type token of interest.
     *
     * @param factory - The factory which will create the instance.
     *
     * #### Notes
     * If the token is already registered, or if registering the factory
     * would cause a circular dependency, an error will be logged to the
     * console and the registration will be ignored.
     */
    Container.prototype.register = function (token, factory) {
        if (this._registry.has(token)) {
            logRegisterError(token);
            return;
        }
        var cycle = findCycle(this._registry, token, factory);
        if (cycle.length > 0) {
            logCycleError(token, cycle);
            return;
        }
        this._registry.set(token, createResolver(factory));
    };
    /**
     * Resolve an instance for the given token or factory.
     *
     * @param value - The token or factory object to resolve.
     *
     * @returns A promise which resolves to an instance of the requested
     *   type, or rejects with an error if an instance fails to resolve.
     */
    Container.prototype.resolve = function (value) {
        var result;
        if (value instanceof Token) {
            result = resolveToken(this._registry, value);
        }
        else {
            result = resolveFactory(this._registry, value);
        }
        return Promise.resolve(result);
    };
    return Container;
})();
exports.Container = Container;
/**
 * Create a new registry instance.
 */
function createRegistry() {
    return new Map();
}
/**
 * Log an error which indicates a token is already registered.
 */
function logRegisterError(token) {
    console.error("Token '" + token.name + "' is already registered.");
}
/**
 * Log an error which indicates a cycle was detected.
 */
function logCycleError(token, cycle) {
    var path = cycle.map(function (token) { return ("'" + token.name + "'"); }).join(' -> ');
    console.error("Cycle detected: '" + token.name + "' -> " + path + ".");
}
/**
 * Create a rejected promise which indicates the token is unregistered.
 */
function rejectUnregistered(token) {
    return Promise.reject(new Error("Unregistered token: '" + token.name + "'."));
}
/**
 * Find a potential cycle in the registry from the given token.
 *
 * This returns an array of tokens which traces the path of the cycle.
 * The given token is the implicit start of the cycle. If no cycle is
 * present, the array will be empty.
 */
function findCycle(registry, token, factory) {
    var trace = [];
    visit(factory);
    return trace;
    function visit(factory) {
        for (var _i = 0, _a = factory.requires; _i < _a.length; _i++) {
            var other = _a[_i];
            trace.push(other);
            if (other === token) {
                return true;
            }
            var resolver = registry.get(other);
            if (resolver && visit(resolver.factory)) {
                return true;
            }
            trace.pop();
        }
        return false;
    }
}
/**
 * Resolve a token using the specified registry.
 */
function resolveToken(registry, token) {
    var result;
    var resolver = registry.get(token);
    if (resolver) {
        result = resolver.resolve(registry);
    }
    else {
        result = rejectUnregistered(token);
    }
    return result;
}
/**
 * Resolve a factory using the specified registry.
 */
function resolveFactory(registry, factory) {
    var promises = factory.requires.map(function (token) { return resolveToken(registry, token); });
    return Promise.all(promises).then(function (dependencies) {
        return factory.create.apply(factory, dependencies);
    });
}
/**
 * Create a resolver for the given factory.
 */
function createResolver(factory) {
    var result;
    if (factory.lifetime === Lifetime.Transient) {
        result = new TransientResolver(factory);
    }
    else {
        result = new SingletonResolver(factory);
    }
    return result;
}
/**
 * A resolver which implements the transient lifetime behavior.
 */
var TransientResolver = (function () {
    /**
     * Construct a new transient resolver.
     */
    function TransientResolver(factory) {
        this._factory = factory;
    }
    Object.defineProperty(TransientResolver.prototype, "factory", {
        /**
         * The factory managed by the resolver.
         */
        get: function () {
            return this._factory;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolve an instance of the type from the factory.
     */
    TransientResolver.prototype.resolve = function (registry) {
        return resolveFactory(registry, this._factory);
    };
    return TransientResolver;
})();
/**
 * A resolver which implements the singleton lifetime behavior.
 */
var SingletonResolver = (function () {
    /**
     * Construct a new transient resolver.
     */
    function SingletonResolver(factory) {
        this._value = null;
        this._resolved = false;
        this._promise = null;
        this._factory = factory;
    }
    Object.defineProperty(SingletonResolver.prototype, "factory", {
        /**
         * The factory managed by the resolver.
         */
        get: function () {
            return this._factory;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolve an instance of the type from the factory.
     */
    SingletonResolver.prototype.resolve = function (registry) {
        var _this = this;
        if (this._resolved) {
            return this._value;
        }
        if (this._promise) {
            return this._promise;
        }
        this._promise = resolveFactory(registry, this._factory).then(function (value) {
            _this._value = value;
            _this._promise = null;
            _this._resolved = true;
            return value;
        }, function (error) {
            _this._promise = null;
            throw error;
        });
        return this._promise;
    };
    return SingletonResolver;
})();
//# sourceMappingURL=index.js.map