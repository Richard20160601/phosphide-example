/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_boxengine_1 = require('phosphor-boxengine');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_widget_1 = require('phosphor-widget');
require('./index.css');
// TODO - need better solution for storing these class names
/**
 * The class name added to BoxPanel instances.
 */
var BOX_PANEL_CLASS = 'p-BoxPanel';
/**
 * The class name added to left-to-right box layout parents.
 */
var LEFT_TO_RIGHT_CLASS = 'p-mod-left-to-right';
/**
 * The class name added to right-to-left box layout parents.
 */
var RIGHT_TO_LEFT_CLASS = 'p-mod-right-to-left';
/**
 * The class name added to top-to-bottom box layout parents.
 */
var TOP_TO_BOTTOM_CLASS = 'p-mod-top-to-bottom';
/**
 * The class name added to bottom-to-top box layout parents.
 */
var BOTTOM_TO_TOP_CLASS = 'p-mod-bottom-to-top';
/**
 * The layout direction of a box layout.
 */
(function (Direction) {
    /**
     * Left to right direction.
     */
    Direction[Direction["LeftToRight"] = 0] = "LeftToRight";
    /**
     * Right to left direction.
     */
    Direction[Direction["RightToLeft"] = 1] = "RightToLeft";
    /**
     * Top to bottom direction.
     */
    Direction[Direction["TopToBottom"] = 2] = "TopToBottom";
    /**
     * Bottom to top direction.
     */
    Direction[Direction["BottomToTop"] = 3] = "BottomToTop";
})(exports.Direction || (exports.Direction = {}));
var Direction = exports.Direction;
/**
 * A panel which arranges its children in a single row or column.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[BoxLayout]].
 */
var BoxPanel = (function (_super) {
    __extends(BoxPanel, _super);
    /**
     * Construct a new box panel.
     */
    function BoxPanel() {
        _super.call(this);
        this.addClass(BOX_PANEL_CLASS);
    }
    /**
     * Create a box layout for a box panel.
     */
    BoxPanel.createLayout = function () {
        return new BoxLayout();
    };
    Object.defineProperty(BoxPanel.prototype, "direction", {
        /**
         * Get the layout direction for the box panel.
         */
        get: function () {
            return this.layout.direction;
        },
        /**
         * Set the layout direction for the box panel.
         */
        set: function (value) {
            this.layout.direction = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoxPanel.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the box panel.
         */
        get: function () {
            return this.layout.spacing;
        },
        /**
         * Set the inter-element spacing for the box panel.
         */
        set: function (value) {
            this.layout.spacing = value;
        },
        enumerable: true,
        configurable: true
    });
    return BoxPanel;
})(phosphor_widget_1.Panel);
exports.BoxPanel = BoxPanel;
/**
 * The namespace for the `BoxPanel` class statics.
 */
var BoxPanel;
(function (BoxPanel) {
    /**
     * A convenience alias of the `LeftToRight` [[Direction]].
     */
    BoxPanel.LeftToRight = Direction.LeftToRight;
    /**
     * A convenience alias of the `RightToLeft` [[Direction]].
     */
    BoxPanel.RightToLeft = Direction.RightToLeft;
    /**
     * A convenience alias of the `TopToBottom` [[Direction]].
     */
    BoxPanel.TopToBottom = Direction.TopToBottom;
    /**
     * A convenience alias of the `BottomToTop` [[Direction]].
     */
    BoxPanel.BottomToTop = Direction.BottomToTop;
    /**
     * Get the box panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box panel stretch factor for the widget.
     */
    function getStretch(widget) {
        return BoxLayout.getStretch(widget);
    }
    BoxPanel.getStretch = getStretch;
    /**
     * Set the box panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        BoxLayout.setStretch(widget, value);
    }
    BoxPanel.setStretch = setStretch;
    /**
     * Get the box panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box panel size basis for the widget.
     */
    function getSizeBasis(widget) {
        return BoxLayout.getSizeBasis(widget);
    }
    BoxPanel.getSizeBasis = getSizeBasis;
    /**
     * Set the box panel size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the size basis.
     */
    function setSizeBasis(widget, value) {
        BoxLayout.setSizeBasis(widget, value);
    }
    BoxPanel.setSizeBasis = setSizeBasis;
})(BoxPanel = exports.BoxPanel || (exports.BoxPanel = {}));
/**
 * A layout which arranges its children in a single row or column.
 */
var BoxLayout = (function (_super) {
    __extends(BoxLayout, _super);
    function BoxLayout() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(BoxLayout.prototype, "direction", {
        /**
         * Get the layout direction for the box layout.
         */
        get: function () {
            return BoxLayoutPrivate.directionProperty.get(this);
        },
        /**
         * Set the layout direction for the box layout.
         */
        set: function (value) {
            BoxLayoutPrivate.directionProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BoxLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the box layout.
         */
        get: function () {
            return BoxLayoutPrivate.spacingProperty.get(this);
        },
        /**
         * Set the inter-element spacing for the box layout.
         */
        set: function (value) {
            BoxLayoutPrivate.spacingProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Initialize the children of the layout.
     *
     * #### Notes
     * This method is called automatically when the layout is installed
     * on its parent widget.
     */
    BoxLayout.prototype.initialize = function () {
        BoxLayoutPrivate.initialize(this);
        _super.prototype.initialize.call(this);
    };
    /**
     * Attach a child widget to the parent's DOM node.
     *
     * @param index - The current index of the child in the layout.
     *
     * @param child - The child widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.attachChild = function (index, child) {
        var sizers = BoxLayoutPrivate.sizersProperty.get(this);
        arrays.insert(sizers, index, new phosphor_boxengine_1.BoxSizer());
        this.parent.node.appendChild(child.node);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgAfterAttach);
        this.parent.fit();
    };
    /**
     * Move a child widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the child in the layout.
     *
     * @param toIndex - The current index of the child in the layout.
     *
     * @param child - The child widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.moveChild = function (fromIndex, toIndex, child) {
        var sizers = BoxLayoutPrivate.sizersProperty.get(this);
        arrays.move(sizers, fromIndex, toIndex);
        this.parent.update();
    };
    /**
     * Detach a child widget from the parent's DOM node.
     *
     * @param index - The previous index of the child in the layout.
     *
     * @param child - The child widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    BoxLayout.prototype.detachChild = function (index, child) {
        var sizers = BoxLayoutPrivate.sizersProperty.get(this);
        arrays.removeAt(sizers, index);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgBeforeDetach);
        this.parent.node.removeChild(child.node);
        BoxLayoutPrivate.resetGeometry(child);
        this.parent.fit();
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    BoxLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    BoxLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    BoxLayout.prototype.onChildShown = function (msg) {
        // IE paints before firing animation frame callbacks when toggling
        // `display: none`. This causes flicker, so IE is fit immediately.
        if (BoxLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    BoxLayout.prototype.onChildHidden = function (msg) {
        // IE paints before firing animation frame callbacks when toggling
        // `display: none`. This causes flicker, so IE is fit immediately.
        if (BoxLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    BoxLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            BoxLayoutPrivate.update(this, msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    BoxLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            BoxLayoutPrivate.update(this, -1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    BoxLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            BoxLayoutPrivate.fit(this);
        }
    };
    return BoxLayout;
})(phosphor_widget_1.PanelLayout);
exports.BoxLayout = BoxLayout;
/**
 * The namespace for the `BoxLayout` class statics.
 */
var BoxLayout;
(function (BoxLayout) {
    /**
     * A convenience alias of the `LeftToRight` [[Direction]].
     */
    BoxLayout.LeftToRight = Direction.LeftToRight;
    /**
     * A convenience alias of the `RightToLeft` [[Direction]].
     */
    BoxLayout.RightToLeft = Direction.RightToLeft;
    /**
     * A convenience alias of the `TopToBottom` [[Direction]].
     */
    BoxLayout.TopToBottom = Direction.TopToBottom;
    /**
     * A convenience alias of the `BottomToTop` [[Direction]].
     */
    BoxLayout.BottomToTop = Direction.BottomToTop;
    /**
     * Get the box layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box layout stretch factor for the widget.
     */
    function getStretch(widget) {
        return BoxLayoutPrivate.stretchProperty.get(widget);
    }
    BoxLayout.getStretch = getStretch;
    /**
     * Set the box layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        BoxLayoutPrivate.stretchProperty.set(widget, value);
    }
    BoxLayout.setStretch = setStretch;
    /**
     * Get the box layout size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The box layout size basis for the widget.
     */
    function getSizeBasis(widget) {
        return BoxLayoutPrivate.sizeBasisProperty.get(widget);
    }
    BoxLayout.getSizeBasis = getSizeBasis;
    /**
     * Set the box layout size basis for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the size basis.
     */
    function setSizeBasis(widget, value) {
        BoxLayoutPrivate.sizeBasisProperty.set(widget, value);
    }
    BoxLayout.setSizeBasis = setSizeBasis;
})(BoxLayout = exports.BoxLayout || (exports.BoxLayout = {}));
/**
 * The namespace for the `BoxLayout` class private data.
 */
var BoxLayoutPrivate;
(function (BoxLayoutPrivate) {
    /**
     * A flag indicating whether the browser is IE.
     */
    BoxLayoutPrivate.IsIE = /Trident/.test(navigator.userAgent);
    /**
     * The property descriptor for the box layout direction.
     */
    BoxLayoutPrivate.directionProperty = new phosphor_properties_1.Property({
        name: 'direction',
        value: Direction.TopToBottom,
        changed: onDirectionChanged,
    });
    /**
     * The property descriptor for the box layout spacing.
     */
    BoxLayoutPrivate.spacingProperty = new phosphor_properties_1.Property({
        name: 'spacing',
        value: 8,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onSpacingChanged,
    });
    /**
     * The property descriptor for the box layout sizers.
     */
    BoxLayoutPrivate.sizersProperty = new phosphor_properties_1.Property({
        name: 'sizers',
        create: function () { return []; },
    });
    /**
     * The property descriptor for a widget stretch factor.
     */
    BoxLayoutPrivate.stretchProperty = new phosphor_properties_1.Property({
        name: 'stretch',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onChildPropertyChanged,
    });
    /**
     * The property descriptor for a widget size basis.
     */
    BoxLayoutPrivate.sizeBasisProperty = new phosphor_properties_1.Property({
        name: 'sizeBasis',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onChildPropertyChanged,
    });
    /**
     * Initialize the private layout state.
     *
     * #### Notes
     * This should be called during layout initialization.
     */
    function initialize(layout) {
        updateParentDirection(layout);
    }
    BoxLayoutPrivate.initialize = initialize;
    /**
     * Reset the layout geometry for the given child widget.
     */
    function resetGeometry(widget) {
        var rect = rectProperty.get(widget);
        var style = widget.node.style;
        rect.top = NaN;
        rect.left = NaN;
        rect.width = NaN;
        rect.height = NaN;
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
    }
    BoxLayoutPrivate.resetGeometry = resetGeometry;
    /**
     * Fit the layout to the total size required by the child widgets.
     */
    function fit(layout) {
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Compute the visible item count.
        var visibleCount = 0;
        for (var i = 0, n = layout.childCount(); i < n; ++i) {
            if (!layout.childAt(i).isHidden)
                visibleCount++;
        }
        // Update the fixed space for the visible items.
        var fixedSpace = layout.spacing * Math.max(0, visibleCount - 1);
        fixedSpaceProperty.set(layout, fixedSpace);
        // Update the sizers and compute the new size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        var dir = layout.direction;
        var sizers = BoxLayoutPrivate.sizersProperty.get(layout);
        if (dir === Direction.LeftToRight || dir === Direction.RightToLeft) {
            minW = fixedSpace;
            maxW = visibleCount > 0 ? minW : maxW;
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                var sizer = sizers[i];
                if (widget.isHidden) {
                    sizer.minSize = 0;
                    sizer.maxSize = 0;
                    continue;
                }
                var limits = phosphor_domutil_1.sizeLimits(widget.node);
                sizer.sizeHint = BoxLayoutPrivate.sizeBasisProperty.get(widget);
                sizer.stretch = BoxLayoutPrivate.stretchProperty.get(widget);
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
                minW += limits.minWidth;
                maxW += limits.maxWidth;
                minH = Math.max(minH, limits.minHeight);
                maxH = Math.min(maxH, limits.maxHeight);
            }
        }
        else {
            minH = fixedSpace;
            maxH = visibleCount > 0 ? minH : maxH;
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                var sizer = sizers[i];
                if (widget.isHidden) {
                    sizer.minSize = 0;
                    sizer.maxSize = 0;
                    continue;
                }
                var limits = phosphor_domutil_1.sizeLimits(widget.node);
                sizer.sizeHint = BoxLayoutPrivate.sizeBasisProperty.get(widget);
                sizer.stretch = BoxLayoutPrivate.stretchProperty.get(widget);
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
                minH += limits.minHeight;
                maxH += limits.maxHeight;
                minW = Math.max(minW, limits.minWidth);
                maxW = Math.min(maxW, limits.maxWidth);
            }
        }
        // Update the box sizing and add it to the size constraints.
        var box = phosphor_domutil_1.boxSizing(parent.node);
        boxSizingProperty.set(parent, box);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the panel's size constraints.
        var style = parent.node.style;
        style.minWidth = minW + 'px';
        style.minHeight = minH + 'px';
        style.maxWidth = maxW === Infinity ? 'none' : maxW + 'px';
        style.maxHeight = maxH === Infinity ? 'none' : maxH + 'px';
        // Notify the ancestor that it should fit immediately.
        if (parent.parent)
            phosphor_messaging_1.sendMessage(parent.parent, phosphor_widget_1.Widget.MsgFitRequest);
        // Notify the parent that it should update immediately.
        phosphor_messaging_1.sendMessage(parent, phosphor_widget_1.Widget.MsgUpdateRequest);
    }
    BoxLayoutPrivate.fit = fit;
    /**
     * Layout the children using the given offset width and height.
     *
     * If the dimensions are unknown, they should be specified as `-1`.
     */
    function update(layout, offsetWidth, offsetHeight) {
        // Bail early if there are no children to layout.
        if (layout.childCount() === 0) {
            return;
        }
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = parent.node.offsetHeight;
        }
        // Lookup the layout data.
        var dir = layout.direction;
        var spacing = layout.spacing;
        var box = boxSizingProperty.get(parent);
        var sizers = BoxLayoutPrivate.sizersProperty.get(layout);
        var fixedSpace = fixedSpaceProperty.get(layout);
        // Compute the actual layout bounds adjusted for border and padding.
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Distribute the layout space and layout the children.
        if (dir === Direction.LeftToRight) {
            phosphor_boxengine_1.boxCalc(sizers, Math.max(0, width - fixedSpace));
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                setGeometry(widget, left, top, size, height);
                left += size + spacing;
            }
        }
        else if (dir === Direction.TopToBottom) {
            phosphor_boxengine_1.boxCalc(sizers, Math.max(0, height - fixedSpace));
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                setGeometry(widget, left, top, width, size);
                top += size + spacing;
            }
        }
        else if (dir === Direction.RightToLeft) {
            left += width;
            phosphor_boxengine_1.boxCalc(sizers, Math.max(0, width - fixedSpace));
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                setGeometry(widget, left - size, top, size, height);
                left -= size + spacing;
            }
        }
        else {
            top += height;
            phosphor_boxengine_1.boxCalc(sizers, Math.max(0, height - fixedSpace));
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                setGeometry(widget, left, top - size, width, size);
                top -= size + spacing;
            }
        }
    }
    BoxLayoutPrivate.update = update;
    /**
     * A property descriptor for a widget offset rect.
     */
    var rectProperty = new phosphor_properties_1.Property({
        name: 'rect',
        create: function () { return ({ top: NaN, left: NaN, width: NaN, height: NaN }); },
    });
    /**
     * A property descriptor for the box sizing of a widget.
     */
    var boxSizingProperty = new phosphor_properties_1.Property({
        name: 'boxSizing',
        create: function (owner) { return phosphor_domutil_1.boxSizing(owner.node); },
    });
    /**
     * A property descriptor for the box layout fixed spacing.
     */
    var fixedSpaceProperty = new phosphor_properties_1.Property({
        name: 'fixedSpace',
        value: 0,
    });
    /**
     * The change handler for the box layout direction.
     */
    function onDirectionChanged(layout) {
        updateParentDirection(layout);
        if (layout.parent)
            layout.parent.fit();
    }
    /**
     * The change handler for the box layout spacing.
     */
    function onSpacingChanged(layout) {
        if (layout.parent)
            layout.parent.fit();
    }
    /**
     * The change handler for the attached child properties.
     */
    function onChildPropertyChanged(child) {
        var parent = child.parent;
        var layout = parent && parent.layout;
        if (layout instanceof BoxLayout)
            parent.fit();
    }
    /**
     * Update the CSS direction class on the layout parent.
     */
    function updateParentDirection(layout) {
        if (!layout.parent)
            return;
        var parent = layout.parent;
        var dir = layout.direction;
        parent.toggleClass(LEFT_TO_RIGHT_CLASS, dir === Direction.LeftToRight);
        parent.toggleClass(RIGHT_TO_LEFT_CLASS, dir === Direction.RightToLeft);
        parent.toggleClass(TOP_TO_BOTTOM_CLASS, dir === Direction.TopToBottom);
        parent.toggleClass(BOTTOM_TO_TOP_CLASS, dir === Direction.BottomToTop);
    }
    /**
     * Set the offset geometry for the given widget.
     *
     * A resize message will be dispatched to the widget if appropriate.
     */
    function setGeometry(widget, left, top, width, height) {
        var resized = false;
        var style = widget.node.style;
        var rect = rectProperty.get(widget);
        if (rect.top !== top) {
            rect.top = top;
            style.top = top + 'px';
        }
        if (rect.left !== left) {
            rect.left = left;
            style.left = left + 'px';
        }
        if (rect.width !== width) {
            resized = true;
            rect.width = width;
            style.width = width + 'px';
        }
        if (rect.height !== height) {
            resized = true;
            rect.height = height;
            style.height = height + 'px';
        }
        if (resized) {
            phosphor_messaging_1.sendMessage(widget, new phosphor_widget_1.ResizeMessage(width, height));
        }
    }
})(BoxLayoutPrivate || (BoxLayoutPrivate = {}));
