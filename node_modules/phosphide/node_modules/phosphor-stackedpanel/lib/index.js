/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
require('./index.css');
/**
 * The class name added to StackedPanel instances.
 */
var STACKED_PANEL_CLASS = 'p-StackedPanel';
/**
 * A panel where only one child widget is visible at a time.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[StackedLayout]].
 */
var StackedPanel = (function (_super) {
    __extends(StackedPanel, _super);
    /**
     * Construct a new stacked panel.
     */
    function StackedPanel() {
        var _this = this;
        _super.call(this);
        this.addClass(STACKED_PANEL_CLASS);
        var layout = this.layout;
        layout.currentChanged.connect(function (sender, args) {
            _this.currentChanged.emit(args);
        });
        layout.widgetRemoved.connect(function (sender, args) {
            _this.widgetRemoved.emit(args);
        });
    }
    /**
     * Create a stacked layout for a stacked panel.
     */
    StackedPanel.createLayout = function () {
        return new StackedLayout();
    };
    Object.defineProperty(StackedPanel.prototype, "currentChanged", {
        /**
         * A signal emitted when the current widget is changed.
         */
        get: function () {
            return StackedPanelPrivate.currentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedPanel.prototype, "widgetRemoved", {
        /**
         * A signal emitted when a widget is removed from the panel.
         */
        get: function () {
            return StackedPanelPrivate.widgetRemovedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedPanel.prototype, "currentWidget", {
        /**
         * Get the current panel widget.
         */
        get: function () {
            return this.layout.currentWidget;
        },
        /**
         * Set the current panel widget.
         */
        set: function (value) {
            this.layout.currentWidget = value;
        },
        enumerable: true,
        configurable: true
    });
    return StackedPanel;
})(phosphor_widget_1.Panel);
exports.StackedPanel = StackedPanel;
/**
 * A layout where only one child widget is visible at a time.
 */
var StackedLayout = (function (_super) {
    __extends(StackedLayout, _super);
    function StackedLayout() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(StackedLayout.prototype, "currentChanged", {
        /**
         * A signal emitted when the current widget is changed.
         */
        get: function () {
            return StackedLayoutPrivate.currentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedLayout.prototype, "widgetRemoved", {
        /**
         * A signal emitted when a widget is removed from the layout.
         */
        get: function () {
            return StackedLayoutPrivate.widgetRemovedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StackedLayout.prototype, "currentWidget", {
        /**
         * Get the current layout widget.
         */
        get: function () {
            return StackedLayoutPrivate.currentWidgetProperty.get(this);
        },
        /**
         * Set the current layout widget.
         */
        set: function (value) {
            StackedLayoutPrivate.currentWidgetProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Attach a child widget to the parent's DOM node.
     *
     * @param index - The current index of the child in the layout.
     *
     * @param child - The child widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.attachChild = function (index, child) {
        child.hide();
        this.parent.node.appendChild(child.node);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgAfterAttach);
    };
    /**
     * Move a child widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the child in the layout.
     *
     * @param toIndex - The current index of the child in the layout.
     *
     * @param child - The child widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.moveChild = function (fromIndex, toIndex, child) { };
    /**
     * Detach a child widget from the parent's DOM node.
     *
     * @param index - The previous index of the child in the layout.
     *
     * @param child - The child widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    StackedLayout.prototype.detachChild = function (index, child) {
        if (child === this.currentWidget)
            this.currentWidget = null;
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgBeforeDetach);
        this.parent.node.removeChild(child.node);
        StackedLayoutPrivate.resetGeometry(child);
        this.widgetRemoved.emit(child);
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    StackedLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    StackedLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    StackedLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            StackedLayoutPrivate.update(this, msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    StackedLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            StackedLayoutPrivate.update(this, -1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    StackedLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            StackedLayoutPrivate.fit(this);
        }
    };
    return StackedLayout;
})(phosphor_widget_1.PanelLayout);
exports.StackedLayout = StackedLayout;
/**
 * The namespace for the `StackedPanel` class private data.
 */
var StackedPanelPrivate;
(function (StackedPanelPrivate) {
    /**
     * A signal emitted when the current widget is changed.
     */
    StackedPanelPrivate.currentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a widget is removed from the panel.
     */
    StackedPanelPrivate.widgetRemovedSignal = new phosphor_signaling_1.Signal();
})(StackedPanelPrivate || (StackedPanelPrivate = {}));
/**
 * The namespace for the `StackedLayout` class private data.
 */
var StackedLayoutPrivate;
(function (StackedLayoutPrivate) {
    /**
     * A flag indicating whether the browser is IE.
     */
    StackedLayoutPrivate.IsIE = /Trident/.test(navigator.userAgent);
    /**
     * A signal emitted when the current widget is changed.
     */
    StackedLayoutPrivate.currentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a widget is removed from the layout.
     */
    StackedLayoutPrivate.widgetRemovedSignal = new phosphor_signaling_1.Signal();
    /**
     * The property descriptor for the current widget.
     */
    StackedLayoutPrivate.currentWidgetProperty = new phosphor_properties_1.Property({
        name: 'currentWidget',
        value: null,
        coerce: coerceCurrentWidget,
        changed: onCurrentWidgetChanged,
        notify: StackedLayoutPrivate.currentChangedSignal,
    });
    /**
     * Reset the layout geometry for the given child widget.
     */
    function resetGeometry(widget) {
        var rect = rectProperty.get(widget);
        var style = widget.node.style;
        rect.top = NaN;
        rect.left = NaN;
        rect.width = NaN;
        rect.height = NaN;
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
    }
    StackedLayoutPrivate.resetGeometry = resetGeometry;
    /**
     * Fit the layout to the total size required by the child widgets.
     */
    function fit(layout) {
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Compute the new size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        var widget = layout.currentWidget;
        if (widget) {
            var limits = phosphor_domutil_1.sizeLimits(widget.node);
            minW = limits.minWidth;
            minH = limits.minHeight;
            maxW = limits.maxWidth;
            maxH = limits.maxHeight;
        }
        // Update the box sizing and add it to the size constraints.
        var box = phosphor_domutil_1.boxSizing(parent.node);
        boxSizingProperty.set(parent, box);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the panel's size constraints.
        var style = parent.node.style;
        style.minWidth = minW + 'px';
        style.minHeight = minH + 'px';
        style.maxWidth = maxW === Infinity ? 'none' : maxW + 'px';
        style.maxHeight = maxH === Infinity ? 'none' : maxH + 'px';
        // Notify the ancestor that it should fit immediately.
        if (parent.parent)
            phosphor_messaging_1.sendMessage(parent.parent, phosphor_widget_1.Widget.MsgFitRequest);
        // Notify the parent that it should update immediately.
        phosphor_messaging_1.sendMessage(parent, phosphor_widget_1.Widget.MsgUpdateRequest);
    }
    StackedLayoutPrivate.fit = fit;
    /**
     * Layout the children using the given offset width and height.
     *
     * If the dimensions are unknown, they should be specified as `-1`.
     */
    function update(layout, offsetWidth, offsetHeight) {
        // Bail early if there is no current widget.
        var widget = layout.currentWidget;
        if (!widget) {
            return;
        }
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = parent.node.offsetHeight;
        }
        // Compute the actual layout bounds adjusted for border and padding.
        var box = boxSizingProperty.get(parent);
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Update the current widget's layout geometry.
        setGeometry(widget, left, top, width, height);
    }
    StackedLayoutPrivate.update = update;
    /**
     * A property descriptor for a widget offset rect.
     */
    var rectProperty = new phosphor_properties_1.Property({
        name: 'rect',
        create: function () { return ({ top: NaN, left: NaN, width: NaN, height: NaN }); },
    });
    /**
     * A property descriptor for the box sizing of a widget.
     */
    var boxSizingProperty = new phosphor_properties_1.Property({
        name: 'boxSizing',
        create: function (owner) { return phosphor_domutil_1.boxSizing(owner.node); },
    });
    /**
     * The coerce handler for the `currentWidget` property.
     */
    function coerceCurrentWidget(owner, value) {
        return (value && owner.childIndex(value) !== -1) ? value : null;
    }
    /**
     * The change handler for the `currentWidget` property.
     */
    function onCurrentWidgetChanged(owner, old, val) {
        if (old)
            old.hide();
        if (val)
            val.show();
        if (!owner.parent)
            return;
        // IE paints before firing animation frame callbacks when toggling
        // `display: none`. This causes flicker, so IE is fit immediately.
        if (StackedLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(owner.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            owner.parent.fit();
        }
    }
    /**
     * Set the offset geometry for the given widget.
     *
     * A resize message will be dispatched to the widget if appropriate.
     */
    function setGeometry(widget, left, top, width, height) {
        var resized = false;
        var style = widget.node.style;
        var rect = rectProperty.get(widget);
        if (rect.top !== top) {
            rect.top = top;
            style.top = top + 'px';
        }
        if (rect.left !== left) {
            rect.left = left;
            style.left = left + 'px';
        }
        if (rect.width !== width) {
            resized = true;
            rect.width = width;
            style.width = width + 'px';
        }
        if (rect.height !== height) {
            resized = true;
            rect.height = height;
            style.height = height + 'px';
        }
        if (resized) {
            phosphor_messaging_1.sendMessage(widget, new phosphor_widget_1.ResizeMessage(width, height));
        }
    }
})(StackedLayoutPrivate || (StackedLayoutPrivate = {}));
