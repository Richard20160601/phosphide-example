/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_signaling_1 = require('phosphor-signaling');
var phosphor_widget_1 = require('phosphor-widget');
// TODO - need better solution for storing these class names
/**
 * The class name added to TabBar instances.
 */
var TAB_BAR_CLASS = 'p-TabBar';
/**
 * The class name added to the tab bar header node.
 */
var HEADER_CLASS = 'p-TabBar-header';
/**
 * The class name added to the tab bar body node.
 */
var BODY_CLASS = 'p-TabBar-body';
/**
 * The class name added to the tab bar content node.
 */
var CONTENT_CLASS = 'p-TabBar-content';
/**
 * The class name added to the tab bar footer node.
 */
var FOOTER_CLASS = 'p-TabBar-footer';
/**
 * The class name added to a tab.
 */
var TAB_CLASS = 'p-TabBar-tab';
/**
 * The class name added to a tab text node.
 */
var TEXT_CLASS = 'p-TabBar-tab-text';
/**
 * The class name added to a tab icon node.
 */
var ICON_CLASS = 'p-TabBar-tab-icon';
/**
 * The class name added to a tab close node.
 */
var CLOSE_CLASS = 'p-TabBar-tab-close';
/**
 * The class name added to a tab bar and tab when dragging.
 */
var DRAGGING_CLASS = 'p-mod-dragging';
/**
 * The class name added to the current tab.
 */
var CURRENT_CLASS = 'p-mod-current';
/**
 * The class name added to a closable tab.
 */
var CLOSABLE_CLASS = 'p-mod-closable';
/**
 * The start drag distance threshold.
 */
var DRAG_THRESHOLD = 5;
/**
 * The detach distance threshold.
 */
var DETACH_THRESHOLD = 20;
/**
 * The tab transition duration.
 */
var TRANSITION_DURATION = 150; // Keep in sync with CSS.
/**
 * A widget which displays titles as a row of selectable tabs.
 */
var TabBar = (function (_super) {
    __extends(TabBar, _super);
    /**
     * Construct a new tab bar.
     */
    function TabBar() {
        _super.call(this);
        this._dirty = false;
        this._tabsMovable = false;
        this._titles = [];
        this._dragData = null;
        this.addClass(TAB_BAR_CLASS);
    }
    /**
     * Create the DOM node for a tab bar.
     */
    TabBar.createNode = function () {
        var node = document.createElement('div');
        var header = document.createElement('div');
        var body = document.createElement('div');
        var content = document.createElement('ul');
        var footer = document.createElement('div');
        header.className = HEADER_CLASS;
        body.className = BODY_CLASS;
        content.className = CONTENT_CLASS;
        footer.className = FOOTER_CLASS;
        body.appendChild(content);
        node.appendChild(header);
        node.appendChild(body);
        node.appendChild(footer);
        return node;
    };
    /**
     * Dispose of the resources held by the widget.
     */
    TabBar.prototype.dispose = function () {
        this._releaseMouse();
        this._titles.length = 0;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabBar.prototype, "tabMoved", {
        /**
         * A signal emitted when a tab is moved by the user.
         */
        get: function () {
            return TabBarPrivate.tabMovedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabCloseRequested", {
        /**
         * A signal emitted when the user clicks a tab's close icon.
         */
        get: function () {
            return TabBarPrivate.tabCloseRequestedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabDetachRequested", {
        /**
         * A signal emitted when a tab is dragged beyond the detach threshold.
         */
        get: function () {
            return TabBarPrivate.tabDetachRequestedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentChanged", {
        /**
         * A signal emitted when the current title is changed.
         */
        get: function () {
            return TabBarPrivate.currentChangedSignal.bind(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "currentTitle", {
        /**
         * Get the currently selected title.
         */
        get: function () {
            return TabBarPrivate.currentTitleProperty.get(this);
        },
        /**
         * Set the currently selected title.
         */
        set: function (value) {
            TabBarPrivate.currentTitleProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         */
        get: function () {
            return this._tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         */
        set: function (value) {
            this._tabsMovable = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "headerNode", {
        /**
         * Get the tab bar header node.
         *
         * #### Notes
         * This can be used to add extra header content.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(HEADER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "bodyNode", {
        /**
         * Get the tab bar body node.
         *
         * #### Notes
         * This can be used to add extra body content.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(BODY_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "contentNode", {
        /**
         * Get the tab bar content node.
         *
         * #### Notes
         * Modifying this node can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(CONTENT_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabBar.prototype, "footerNode", {
        /**
         * Get the tab bar footer node.
         *
         * #### Notes
         * This can be used to add extra footer content.
         *
         * This is a read-only property.
         */
        get: function () {
            return this.node.getElementsByClassName(FOOTER_CLASS)[0];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the number of title objects in the tab bar.
     *
     * @returns The number of title objects in the tab bar.
     */
    TabBar.prototype.titleCount = function () {
        return this._titles.length;
    };
    /**
     * Get the title object at the specified index.
     *
     * @param index - The index of the title object of interest.
     *
     * @returns The title at the specified index, or `undefined`.
     */
    TabBar.prototype.titleAt = function (index) {
        return this._titles[index];
    };
    /**
     * Get the index of the specified title object.
     *
     * @param title - The title object of interest.
     *
     * @returns The index of the specified title, or `-1`.
     */
    TabBar.prototype.titleIndex = function (title) {
        return this._titles.indexOf(title);
    };
    /**
     * Add a title object to the end of the tab bar.
     *
     * @param title - The title object to add to the tab bar.
     *
     * #### Notes
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.addTitle = function (title) {
        this.insertTitle(this.titleCount(), title);
    };
    /**
     * Insert a title object at the specified index.
     *
     * @param index - The index at which to insert the title.
     *
     * @param title - The title object to insert into to the tab bar.
     *
     * #### Notes
     * If the title is already added to the tab bar, it will be moved.
     */
    TabBar.prototype.insertTitle = function (index, title) {
        // Release the mouse before making changes.
        this._releaseMouse();
        // Insert the new title or move an existing title.
        var n = this.titleCount();
        var i = this.titleIndex(title);
        var j = Math.max(0, Math.min(index | 0, n));
        if (i !== -1) {
            if (j === n)
                j--;
            if (i === j)
                return;
            arrays.move(this._titles, i, j);
        }
        else {
            arrays.insert(this._titles, j, title);
            title.changed.connect(this._onTitleChanged, this);
            if (!this.currentTitle)
                this.currentTitle = title;
        }
        // Flip the dirty flag and schedule a full update.
        this._dirty = true;
        this.update();
    };
    /**
     * Remove a title object from the tab bar.
     *
     * @param title - The title object to remove from the tab bar.
     *
     * #### Notes
     * If the title is not in the tab bar, this is a no-op.
     */
    TabBar.prototype.removeTitle = function (title) {
        // Release the mouse before making changes.
        this._releaseMouse();
        // Remove the specified title, or bail if it doesn't exist.
        var i = arrays.remove(this._titles, title);
        if (i === -1) {
            return;
        }
        // Disconnect the title changed handler.
        title.changed.disconnect(this._onTitleChanged, this);
        // Selected the next best tab if removing the current tab.
        if (this.currentTitle === title) {
            this.currentTitle = this._titles[i] || this._titles[i - 1];
        }
        // Flip the dirty flag and schedule a full update.
        this._dirty = true;
        this.update();
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     *
     * #### Notes
     * This will cause the tab bar to stop handling mouse events and to
     * restore the tabs to their non-dragged positions.
     */
    TabBar.prototype.releaseMouse = function () {
        this._releaseMouse();
    };
    /**
     * Handle the DOM events for the tab bar.
     *
     * @param event - The DOM event sent to the tab bar.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the tab bar's DOM node. It should
     * not be called directly by user code.
     */
    TabBar.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'click':
                this._evtClick(event);
                break;
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'contextmenu':
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    TabBar.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('click', this);
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    TabBar.prototype.onBeforeDetach = function (msg) {
        this._releaseMouse();
        this.node.removeEventListener('click', this);
        this.node.removeEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    TabBar.prototype.onUpdateRequest = function (msg) {
        if (this._dirty) {
            this._dirty = false;
            TabBarPrivate.updateTabs(this);
        }
        else {
            TabBarPrivate.updateZOrder(this);
        }
    };
    /**
     * Handle the `'keydown'` event for the tab bar.
     */
    TabBar.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27)
            this._releaseMouse();
    };
    /**
     * Handle the `'click'` event for the tab bar.
     */
    TabBar.prototype._evtClick = function (event) {
        // Do nothing if it's not a left click.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the click is not on a tab.
        var i = TabBarPrivate.hitTestTabs(this, event.clientX, event.clientY);
        if (i < 0) {
            return;
        }
        // Clicking on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the click if the title is not closable.
        var title = this._titles[i];
        if (!title.closable) {
            return;
        }
        // Ignore the click if the close icon wasn't clicked.
        var icon = TabBarPrivate.closeIconNode(this, i);
        if (!icon.contains(event.target)) {
            return;
        }
        // Emit the tab close requested signal.
        this.tabCloseRequested.emit(title);
    };
    /**
     * Handle the `'mousedown'` event for the tab bar.
     */
    TabBar.prototype._evtMouseDown = function (event) {
        // Do nothing if it's not a left mouse press.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if a drag is in progress.
        if (this._dragData) {
            return;
        }
        // Do nothing if the press is not on a tab.
        var i = TabBarPrivate.hitTestTabs(this, event.clientX, event.clientY);
        if (i < 0) {
            return;
        }
        // Pressing on a tab stops the event propagation.
        event.preventDefault();
        event.stopPropagation();
        // Ignore the press if it was on a close icon.
        var icon = TabBarPrivate.closeIconNode(this, i);
        if (icon.contains(event.target)) {
            return;
        }
        // Setup the drag data if the tabs are movable.
        if (this._tabsMovable) {
            this._dragData = TabBarPrivate.initDrag(i, event);
            document.addEventListener('mousemove', this, true);
            document.addEventListener('mouseup', this, true);
            document.addEventListener('keydown', this, true);
            document.addEventListener('contextmenu', this, true);
        }
        // Update the current title.
        this.currentTitle = this._titles[i];
    };
    /**
     * Handle the `'mousemove'` event for the tab bar.
     */
    TabBar.prototype._evtMouseMove = function (event) {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag.
        event.preventDefault();
        event.stopPropagation();
        // Update the tab drag positions.
        TabBarPrivate.moveDrag(this, this._dragData, event);
    };
    /**
     * Handle the `'mouseup'` event for the tab bar.
     */
    TabBar.prototype._evtMouseUp = function (event) {
        var _this = this;
        // Do nothing if it's not a left mouse release.
        if (event.button !== 0) {
            return;
        }
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Suppress the event during a drag operation.
        event.preventDefault();
        event.stopPropagation();
        // Remove the extra mouse event listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // End the drag operation.
        TabBarPrivate.endDrag(this, this._dragData, event, {
            clear: function () { _this._dragData = null; },
            move: function (i, j) { _this._moveTab(i, j); },
        });
    };
    /**
     * Release the mouse and restore the non-dragged tab positions.
     */
    TabBar.prototype._releaseMouse = function () {
        // Do nothing if no drag is in progress.
        if (!this._dragData) {
            return;
        }
        // Remove the extra mouse listeners.
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('contextmenu', this, true);
        // Abort the drag operation and clear the drag data.
        TabBarPrivate.abortDrag(this, this._dragData);
        this._dragData = null;
    };
    /**
     * Move a tab from one index to another.
     */
    TabBar.prototype._moveTab = function (i, j) {
        var k = j < i ? j : j + 1;
        var content = this.contentNode;
        var children = content.children;
        arrays.move(this._titles, i, j);
        content.insertBefore(children[i], children[k]);
        this.tabMoved.emit({ fromIndex: i, toIndex: j });
        this.update();
    };
    /**
     * Handle the `changed` signal of a title object.
     */
    TabBar.prototype._onTitleChanged = function (sender) {
        this._dirty = true;
        this.update();
    };
    return TabBar;
})(phosphor_widget_1.Widget);
exports.TabBar = TabBar;
/**
 * A struct which holds the drag data for a tab bar.
 */
var DragData = (function () {
    function DragData() {
        /**
         * The tab node being dragged.
         */
        this.tab = null;
        /**
         * The index of the tab being dragged.
         */
        this.tabIndex = -1;
        /**
         * The offset left of the tab being dragged.
         */
        this.tabLeft = -1;
        /**
         * The offset width of the tab being dragged.
         */
        this.tabWidth = -1;
        /**
         * The original mouse X position in tab coordinates.
         */
        this.tabPressX = -1;
        /**
         * The tab target index upon mouse release.
         */
        this.targetIndex = -1;
        /**
         * The array of tab layout objects snapped at drag start.
         */
        this.tabLayout = null;
        /**
         * The mouse press client X position.
         */
        this.pressX = -1;
        /**
         * The mouse press client Y position.
         */
        this.pressY = -1;
        /**
         * The bounding client rect of the tab bar content node.
         */
        this.contentRect = null;
        /**
         * The disposable to clean up the cursor override.
         */
        this.cursorGrab = null;
        /**
         * Whether the drag is currently active.
         */
        this.dragActive = false;
        /**
         * Whether the drag has been aborted.
         */
        this.dragAborted = false;
        /**
         * Whether a detach request as been made.
         */
        this.detachRequested = false;
    }
    return DragData;
})();
/**
 * The namespace for the `TabBar` class private data.
 */
var TabBarPrivate;
(function (TabBarPrivate) {
    /**
     * A signal emitted when the current title is changed.
     */
    TabBarPrivate.currentChangedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a tab is moved by the user.
     */
    TabBarPrivate.tabMovedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when the user clicks a tab's close icon.
     */
    TabBarPrivate.tabCloseRequestedSignal = new phosphor_signaling_1.Signal();
    /**
     * A signal emitted when a tab is dragged beyond the detach threshold.
     */
    TabBarPrivate.tabDetachRequestedSignal = new phosphor_signaling_1.Signal();
    /**
     * The property descriptor for the currently selected title.
     */
    TabBarPrivate.currentTitleProperty = new phosphor_properties_1.Property({
        name: 'currentTitle',
        value: null,
        coerce: coerceCurrentTitle,
        changed: onCurrentTitleChanged,
        notify: TabBarPrivate.currentChangedSignal,
    });
    /**
     * Get the close icon node for the tab at the specified index.
     */
    function closeIconNode(owner, index) {
        return owner.contentNode.children[index].lastChild;
    }
    TabBarPrivate.closeIconNode = closeIconNode;
    /**
     * Get the index of the tab node at a client position, or `-1`.
     */
    function hitTestTabs(owner, x, y) {
        var nodes = owner.contentNode.children;
        for (var i = 0, n = nodes.length; i < n; ++i) {
            if (phosphor_domutil_1.hitTest(nodes[i], x, y))
                return i;
        }
        return -1;
    }
    TabBarPrivate.hitTestTabs = hitTestTabs;
    /**
     * Update the tab bar tabs to match the current titles.
     *
     * This is a full update which also updates the tab Z order.
     */
    function updateTabs(owner) {
        var count = owner.titleCount();
        var content = owner.contentNode;
        var children = content.children;
        var current = owner.currentTitle;
        while (children.length > count) {
            content.removeChild(content.lastChild);
        }
        while (children.length < count) {
            content.appendChild(createTabNode());
        }
        for (var i = 0; i < count; ++i) {
            var node = children[i];
            updateTabNode(node, owner.titleAt(i));
        }
        updateZOrder(owner);
    }
    TabBarPrivate.updateTabs = updateTabs;
    /**
     * Update the Z order of the tabs to match the current titles.
     *
     * This is a partial update which updates the Z order and the current
     * tab class. It assumes the tab count is the same as the title count.
     */
    function updateZOrder(owner) {
        var count = owner.titleCount();
        var content = owner.contentNode;
        var children = content.children;
        var current = owner.currentTitle;
        for (var i = 0; i < count; ++i) {
            var node = children[i];
            if (owner.titleAt(i) === current) {
                node.classList.add(CURRENT_CLASS);
                node.style.zIndex = count + '';
            }
            else {
                node.classList.remove(CURRENT_CLASS);
                node.style.zIndex = count - i - 1 + '';
            }
        }
    }
    TabBarPrivate.updateZOrder = updateZOrder;
    /**
     * Initialize a new drag data object for a tab bar.
     *
     * This should be called on 'mousedown' event.
     */
    function initDrag(tabIndex, event) {
        var data = new DragData();
        data.tabIndex = tabIndex;
        data.pressX = event.clientX;
        data.pressY = event.clientY;
        return data;
    }
    TabBarPrivate.initDrag = initDrag;
    /**
     * Update the drag positions of the tabs for a tab bar.
     *
     * This should be called on a `'mousemove'` event.
     */
    function moveDrag(owner, data, event) {
        // Ensure the drag threshold is exceeded before moving the tab.
        if (!data.dragActive) {
            var dx = Math.abs(event.clientX - data.pressX);
            var dy = Math.abs(event.clientY - data.pressY);
            if (dx < DRAG_THRESHOLD && dy < DRAG_THRESHOLD) {
                return;
            }
            // Fill in the missing drag data measurements.
            var content = owner.contentNode;
            var tab = content.children[data.tabIndex];
            var tabRect = tab.getBoundingClientRect();
            data.tab = tab;
            data.tabLeft = tab.offsetLeft;
            data.tabWidth = tabRect.width;
            data.tabPressX = data.pressX - tabRect.left;
            data.contentRect = content.getBoundingClientRect();
            data.tabLayout = snapTabLayout(owner);
            data.cursorGrab = phosphor_domutil_1.overrideCursor('default');
            // Style the tab bar and tab for relative position dragging.
            tab.classList.add(DRAGGING_CLASS);
            owner.addClass(DRAGGING_CLASS);
            data.dragActive = true;
        }
        // Emit the detach request signal if the threshold is exceeded.
        if (!data.detachRequested && detachExceeded(data.contentRect, event)) {
            var node = data.tab;
            var clientX = event.clientX;
            var clientY = event.clientY;
            var title = owner.titleAt(data.tabIndex);
            owner.tabDetachRequested.emit({ title: title, node: node, clientX: clientX, clientY: clientY });
            data.detachRequested = true;
            if (data.dragAborted) {
                return;
            }
        }
        // Compute the target bounds of the drag tab.
        var offsetLeft = event.clientX - data.contentRect.left;
        var targetLeft = offsetLeft - data.tabPressX;
        var targetRight = targetLeft + data.tabWidth;
        // Reset the target tab index.
        data.targetIndex = data.tabIndex;
        // Update the non-drag tab positions and the tab target index.
        var tabs = owner.contentNode.children;
        for (var i = 0, n = tabs.length; i < n; ++i) {
            var layout = data.tabLayout[i];
            var style = tabs[i].style;
            var threshold = layout.left + (layout.width >> 1);
            if (i < data.tabIndex && targetLeft < threshold) {
                style.left = data.tabWidth + data.tabLayout[i + 1].margin + 'px';
                data.targetIndex = Math.min(data.targetIndex, i);
            }
            else if (i > data.tabIndex && targetRight > threshold) {
                style.left = -data.tabWidth - layout.margin + 'px';
                data.targetIndex = i;
            }
            else if (i !== data.tabIndex) {
                style.left = '';
            }
        }
        // Update the drag tab position.
        var idealLeft = event.clientX - data.pressX;
        var maxLeft = data.contentRect.width - (data.tabLeft + data.tabWidth);
        var adjustedLeft = Math.max(-data.tabLeft, Math.min(idealLeft, maxLeft));
        data.tab.style.left = adjustedLeft + 'px';
    }
    TabBarPrivate.moveDrag = moveDrag;
    /**
     * End the drag operation for a tab bar.
     *
     * This should be called on a `'mouseup'` event.
     */
    function endDrag(owner, data, event, handler) {
        // Bail early if the drag is not active.
        if (!data.dragActive) {
            handler.clear();
            return;
        }
        // Compute the approximate final relative tab offset.
        var idealLeft;
        if (data.targetIndex === data.tabIndex) {
            idealLeft = 0;
        }
        else if (data.targetIndex > data.tabIndex) {
            var tl = data.tabLayout[data.targetIndex];
            idealLeft = tl.left + tl.width - data.tabWidth - data.tabLeft;
        }
        else {
            var tl = data.tabLayout[data.targetIndex];
            idealLeft = tl.left - data.tabLeft;
        }
        // Position the tab to its final position, subject to limits.
        var maxLeft = data.contentRect.width - (data.tabLeft + data.tabWidth);
        var adjustedLeft = Math.max(-data.tabLeft, Math.min(idealLeft, maxLeft));
        data.tab.style.left = adjustedLeft + 'px';
        // Remove the dragging class from the tab so it can be transitioned.
        data.tab.classList.remove(DRAGGING_CLASS);
        // Complete the release on a timer to allow the tab to transition.
        setTimeout(function () {
            // Do nothing if the drag has been aborted.
            if (data.dragAborted) {
                return;
            }
            // Clear the drag data reference.
            handler.clear();
            // Reset the positions of the tabs.
            resetTabPositions(owner);
            // Clear the cursor grab and drag styles.
            data.cursorGrab.dispose();
            owner.removeClass(DRAGGING_CLASS);
            // Finally, move the tab to its new location.
            if (data.targetIndex !== -1 && data.tabIndex !== data.targetIndex) {
                handler.move(data.tabIndex, data.targetIndex);
            }
        }, TRANSITION_DURATION);
    }
    TabBarPrivate.endDrag = endDrag;
    /**
     * Abort the drag operation for a tab bar.
     *
     * This should be called to cancel a drag immediately.
     */
    function abortDrag(owner, data) {
        // Indicate the drag has been aborted, which allows the drag
        // end handler and detach request emitter to return early.
        data.dragAborted = true;
        // If the drag is not active, there's nothing more to do.
        if (!data.dragActive) {
            return;
        }
        // Reset the tabs to their non-dragged positions.
        resetTabPositions(owner);
        // Clear the cursor override and extra styling classes.
        data.cursorGrab.dispose();
        data.tab.classList.remove(DRAGGING_CLASS);
        owner.removeClass(DRAGGING_CLASS);
    }
    TabBarPrivate.abortDrag = abortDrag;
    /**
     * The coerce handler for the `currentTitle` property.
     */
    function coerceCurrentTitle(owner, value) {
        return (value && owner.titleIndex(value) !== -1) ? value : null;
    }
    /**
     * The change handler for the `currentTitle` property.
     */
    function onCurrentTitleChanged(owner) {
        owner.update();
    }
    /**
     * Create an uninitialized DOM node for a tab.
     */
    function createTabNode() {
        var node = document.createElement('li');
        var icon = document.createElement('span');
        var text = document.createElement('span');
        var close = document.createElement('span');
        text.className = TEXT_CLASS;
        close.className = CLOSE_CLASS;
        node.appendChild(icon);
        node.appendChild(text);
        node.appendChild(close);
        return node;
    }
    /**
     * Update a tab node to reflect the state of a title.
     */
    function updateTabNode(node, title) {
        var icon = node.firstChild;
        var text = icon.nextSibling;
        var suffix = title.closable ? ' ' + CLOSABLE_CLASS : '';
        if (title.className) {
            node.className = TAB_CLASS + ' ' + title.className + suffix;
        }
        else {
            node.className = TAB_CLASS + suffix;
        }
        if (title.icon) {
            icon.className = ICON_CLASS + ' ' + title.icon;
        }
        else {
            icon.className = ICON_CLASS;
        }
        text.textContent = title.text;
    }
    /**
     * Reset the tabs to their unadjusted positions.
     */
    function resetTabPositions(owner) {
        var children = owner.contentNode.children;
        for (var i = 0, n = children.length; i < n; ++i) {
            children[i].style.left = '';
        }
    }
    /**
     * Get a snapshot of the current tab layout values.
     */
    function snapTabLayout(owner) {
        var layout = [];
        var children = owner.contentNode.children;
        for (var i = 0, n = children.length; i < n; ++i) {
            var node = children[i];
            var left = node.offsetLeft;
            var width = node.offsetWidth;
            var cstyle = window.getComputedStyle(node);
            var margin = parseInt(cstyle.marginLeft, 10) || 0;
            layout.push({ margin: margin, left: left, width: width });
        }
        return layout;
    }
    /**
     * Test if a mouse position exceeds the detach threshold.
     */
    function detachExceeded(rect, event) {
        return ((event.clientX < rect.left - DETACH_THRESHOLD) ||
            (event.clientX >= rect.right + DETACH_THRESHOLD) ||
            (event.clientY < rect.top - DETACH_THRESHOLD) ||
            (event.clientY >= rect.bottom + DETACH_THRESHOLD));
    }
})(TabBarPrivate || (TabBarPrivate = {}));
