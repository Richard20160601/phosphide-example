/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var phosphor_boxpanel_1 = require('phosphor-boxpanel');
var phosphor_stackedpanel_1 = require('phosphor-stackedpanel');
var phosphor_widget_1 = require('phosphor-widget');
var tabbar_1 = require('./tabbar');
// TODO - need better solution for storing these class names
/**
 * The class name added to TabPanel instances.
 */
var TAB_PANEL_CLASS = 'p-TabPanel';
/**
 * A widget which combines a `TabBar` and a `StackedPanel`.
 *
 * #### Notes
 * This is a simple panel which handles the common case of a tab bar
 * placed above a content area. The selected tab controls the widget
 * which is shown in the content area.
 *
 * For use cases which require more control than is provided by this
 * panel, the `TabBar` widget may be used independently.
 */
var TabPanel = (function (_super) {
    __extends(TabPanel, _super);
    /**
     * Construct a new tab panel.
     */
    function TabPanel() {
        _super.call(this);
        this.addClass(TAB_PANEL_CLASS);
        var type = this.constructor;
        this._tabBar = type.createTabBar();
        this._stackedPanel = type.createStackedPanel();
        this._tabBar.tabMoved.connect(this.onTabMoved, this);
        this._tabBar.currentChanged.connect(this.onCurrentChanged, this);
        this._tabBar.tabCloseRequested.connect(this.onTabCloseRequested, this);
        this._stackedPanel.widgetRemoved.connect(this.onWidgetRemoved, this);
        phosphor_boxpanel_1.BoxLayout.setStretch(this._tabBar, 0);
        phosphor_boxpanel_1.BoxLayout.setStretch(this._stackedPanel, 1);
        var layout = new phosphor_boxpanel_1.BoxLayout();
        layout.direction = phosphor_boxpanel_1.BoxLayout.TopToBottom;
        layout.spacing = 0;
        layout.addChild(this._tabBar);
        layout.addChild(this._stackedPanel);
        this.layout = layout;
    }
    /**
     * Create a `TabBar` for a tab panel.
     *
     * @returns The tab bar to use with a new tab panel.
     *
     * #### Notes
     * This may be reimplemented by a subclass as needed.
     */
    TabPanel.createTabBar = function () {
        return new tabbar_1.TabBar();
    };
    /**
     * Create a `StackedPanel` for a tab panel.
     *
     * @returns The stacked panel to use with a new tab panel.
     *
     * #### Notes
     * This may be reimplemented by a subclass as needed.
     */
    TabPanel.createStackedPanel = function () {
        return new phosphor_stackedpanel_1.StackedPanel();
    };
    /**
     * Dispose of the resources held by the widget.
     */
    TabPanel.prototype.dispose = function () {
        this._tabBar = null;
        this._stackedPanel = null;
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(TabPanel.prototype, "currentWidget", {
        /**
         * Get the currently selected widget.
         */
        get: function () {
            return this._stackedPanel.currentWidget;
        },
        /**
         * Set the currently selected widget.
         */
        set: function (widget) {
            this._tabBar.currentTitle = widget && widget.title;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "tabsMovable", {
        /**
         * Get whether the tabs are movable by the user.
         */
        get: function () {
            return this._tabBar.tabsMovable;
        },
        /**
         * Set whether the tabs are movable by the user.
         */
        set: function (movable) {
            this._tabBar.tabsMovable = movable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "tabBar", {
        /**
         * Get the tab bar associated with the tab panel.
         *
         * #### Notes
         * Modifying the tab bar titles can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._tabBar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TabPanel.prototype, "stackedPanel", {
        /**
         * Get the stacked panel associated with the tab panel.
         *
         * #### Notes
         * Modifying the panel children can lead to undefined behavior.
         *
         * This is a read-only property.
         */
        get: function () {
            return this._stackedPanel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the number of child widgets in the tab panel.
     *
     * @returns The number of child widgets in the tab panel.
     *
     * #### Notes
     * This delegates to `childCount` of the internal stacked panel.
     */
    TabPanel.prototype.childCount = function () {
        return this._stackedPanel.childCount();
    };
    /**
     * Get the child widget at the specified index.
     *
     * @param index - The index of the child widget of interest.
     *
     * @returns The child at the specified index, or `undefined`.
     *
     * #### Notes
     * This delegates to `childAt` of the internal stacked panel.
     */
    TabPanel.prototype.childAt = function (index) {
        return this._stackedPanel.childAt(index);
    };
    /**
     * Get the index of the specified child widget.
     *
     * @param child - The child widget of interest.
     *
     * @returns The index of the specified child, or `-1`.
     *
     * #### Notes
     * This delegates to `childIndex` of the internal stacked panel.
     */
    TabPanel.prototype.childIndex = function (child) {
        return this._stackedPanel.childIndex(child);
    };
    /**
     * Add a child widget to the end of the tab panel.
     *
     * @param child - The child widget to add to the tab panel.
     *
     * #### Notes
     * If the child is already contained in the panel, it will be moved.
     *
     * This adds the widget's title object to the internal tab bar, and
     * adds the widget itself to the internal stacked panel.
     */
    TabPanel.prototype.addChild = function (child) {
        this._stackedPanel.addChild(child);
        this._tabBar.addTitle(child.title);
    };
    /**
     * Insert a child widget at the specified index.
     *
     * @param index - The index at which to insert the child.
     *
     * @param child - The child widget to insert into to the tab panel.
     *
     * #### Notes
     * If the child is already contained in the panel, it will be moved.
     *
     * This adds the widget's title object to the internal tab bar, and
     * adds the widget itself to the internal stacked panel.
     */
    TabPanel.prototype.insertChild = function (index, child) {
        this._stackedPanel.insertChild(index, child);
        this._tabBar.insertTitle(index, child.title);
    };
    /**
     * Find the widget which owns the given title.
     *
     * @param title - The title object of interest.
     *
     * @returns The widget which owns the title, or `null` if no such
     *   widget is contained within the internal stacked panel.
     */
    TabPanel.prototype.findWidgetByTitle = function (title) {
        var panel = this._stackedPanel;
        for (var i = 0, n = panel.childCount(); i < n; ++i) {
            var child = panel.childAt(i);
            if (child.title === title)
                return child;
        }
        return null;
    };
    /**
     * Handle the `currentChanged` signal from the tab bar.
     *
     * #### Notes
     * The default implementation updates the current stack widget.
     */
    TabPanel.prototype.onCurrentChanged = function (sender, args) {
        this._stackedPanel.currentWidget = this.findWidgetByTitle(args.newValue);
    };
    /**
     * Handle the `tabMoved` signal from the tab bar.
     *
     * #### Notes
     * The default implementation moves the widget in the stack.
     */
    TabPanel.prototype.onTabMoved = function (sender, args) {
        var child = this._stackedPanel.childAt(args.fromIndex);
        this._stackedPanel.insertChild(args.toIndex, child);
    };
    /**
     * Handle the `tabCloseRequested` signal from the tab bar.
     *
     * #### Notes
     * The default implementation closes the respective widget.
     */
    TabPanel.prototype.onTabCloseRequested = function (sender, title) {
        var widget = this.findWidgetByTitle(title);
        if (widget)
            widget.close();
    };
    /**
     * Handle the `widgetRemoved` signal from the stacked panel.
     *
     * #### Notes
     * The default implementation removes the title from the tab bar.
     */
    TabPanel.prototype.onWidgetRemoved = function (sender, widget) {
        this._tabBar.removeTitle(widget.title);
    };
    return TabPanel;
})(phosphor_widget_1.Widget);
exports.TabPanel = TabPanel;
