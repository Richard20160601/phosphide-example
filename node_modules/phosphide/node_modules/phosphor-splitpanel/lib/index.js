/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_boxengine_1 = require('phosphor-boxengine');
var phosphor_domutil_1 = require('phosphor-domutil');
var phosphor_messaging_1 = require('phosphor-messaging');
var phosphor_nodewrapper_1 = require('phosphor-nodewrapper');
var phosphor_properties_1 = require('phosphor-properties');
var phosphor_widget_1 = require('phosphor-widget');
require('./index.css');
// TODO - need better solution for storing these class names
/**
 * The class name added to SplitPanel instances.
 */
var SPLIT_PANEL_CLASS = 'p-SplitPanel';
/**
 * The class name added to SplitHandle instances.
 */
var SPLIT_HANDLE_CLASS = 'p-SplitHandle';
/**
 * The class name added to a split handle overlay.
 */
var OVERLAY_CLASS = 'p-SplitHandle-overlay';
/**
 * The class name added to horizontal split layout parents and handles.
 */
var HORIZONTAL_CLASS = 'p-mod-horizontal';
/**
 * The class name added to vertical split layout parents and handles.
 */
var VERTICAL_CLASS = 'p-mod-vertical';
/**
 * The class name added to hidden split handles.
 */
var HIDDEN_CLASS = 'p-mod-hidden';
/**
 * The layout orientation of a split layout.
 */
(function (Orientation) {
    /**
     * Left-to-right horizontal orientation.
     */
    Orientation[Orientation["Horizontal"] = 0] = "Horizontal";
    /**
     * Top-to-bottom vertical orientation.
     */
    Orientation[Orientation["Vertical"] = 1] = "Vertical";
})(exports.Orientation || (exports.Orientation = {}));
var Orientation = exports.Orientation;
/**
 * A panel which arranges its children into resizable sections.
 *
 * #### Notes
 * This class provides a convenience wrapper around a [[SplitLayout]].
 */
var SplitPanel = (function (_super) {
    __extends(SplitPanel, _super);
    /**
     * Construct a new split panel.
     */
    function SplitPanel() {
        _super.call(this);
        this._pressData = null;
        this.addClass(SPLIT_PANEL_CLASS);
    }
    /**
     * Create a split layout for a split panel.
     */
    SplitPanel.createLayout = function () {
        return new SplitLayout();
    };
    /**
     * Dispose of the resources held by the panel.
     */
    SplitPanel.prototype.dispose = function () {
        this._releaseMouse();
        _super.prototype.dispose.call(this);
    };
    Object.defineProperty(SplitPanel.prototype, "orientation", {
        /**
         * Get the layout orientation for the split panel.
         */
        get: function () {
            return this.layout.orientation;
        },
        /**
         * Set the layout orientation for the split panel.
         */
        set: function (value) {
            this.layout.orientation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitPanel.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the split panel.
         */
        get: function () {
            return this.layout.spacing;
        },
        /**
         * Set the inter-element spacing for the split panel.
         */
        set: function (value) {
            this.layout.spacing = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the normalized sizes of the widgets in the panel.
     *
     * @returns The normalized sizes of the widgets in the panel.
     */
    SplitPanel.prototype.sizes = function () {
        return this.layout.sizes();
    };
    /**
     * Set the relative sizes for the child widgets in the panel.
     *
     * @param sizes - The relative sizes for the children in the panel.
     *   These values will be normalized to the available layout space.
     *
     * #### Notes
     * Extra values are ignored, too few will yield an undefined layout.
     */
    SplitPanel.prototype.setSizes = function (sizes) {
        this.layout.setSizes(sizes);
    };
    /**
     * Handle the DOM events for the split panel.
     *
     * @param event - The DOM event sent to the panel.
     *
     * #### Notes
     * This method implements the DOM `EventListener` interface and is
     * called in response to events on the panel's DOM node. It should
     * not be called directly by user code.
     */
    SplitPanel.prototype.handleEvent = function (event) {
        switch (event.type) {
            case 'mousedown':
                this._evtMouseDown(event);
                break;
            case 'mousemove':
                this._evtMouseMove(event);
                break;
            case 'mouseup':
                this._evtMouseUp(event);
                break;
            case 'keydown':
                this._evtKeyDown(event);
                break;
            case 'keyup':
            case 'keypress':
            case 'contextmenu':
                // Stop all input events during drag.
                event.preventDefault();
                event.stopPropagation();
                break;
        }
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    SplitPanel.prototype.onAfterAttach = function (msg) {
        this.node.addEventListener('mousedown', this);
    };
    /**
     * A message handler invoked on a `'before-detach'` message.
     */
    SplitPanel.prototype.onBeforeDetach = function (msg) {
        this.node.removeEventListener('mousedown', this);
    };
    /**
     * Handle the `'keydown'` event for the split panel.
     */
    SplitPanel.prototype._evtKeyDown = function (event) {
        // Stop all input events during drag.
        event.preventDefault();
        event.stopPropagation();
        // Release the mouse if `Escape` is pressed.
        if (event.keyCode === 27)
            this._releaseMouse();
    };
    /**
     * Handle the `'mousedown'` event for the split panel.
     */
    SplitPanel.prototype._evtMouseDown = function (event) {
        // Do nothing if the left mouse button is not pressed.
        if (event.button !== 0) {
            return;
        }
        // Check if the mouse press is on a split handle.
        var layout = this.layout;
        var target = event.target;
        var _a = layout.findHandle(target), index = _a.index, handle = _a.handle;
        if (index === -1) {
            return;
        }
        // Stop the event when a split handle is pressed.
        event.preventDefault();
        event.stopPropagation();
        // Add the extra document listeners.
        document.addEventListener('mouseup', this, true);
        document.addEventListener('mousemove', this, true);
        document.addEventListener('keydown', this, true);
        document.addEventListener('keyup', this, true);
        document.addEventListener('keypress', this, true);
        document.addEventListener('contextmenu', this, true);
        // Compute the offset delta for the handle press.
        var delta;
        var rect = handle.getBoundingClientRect();
        if (layout.orientation === Orientation.Horizontal) {
            delta = event.clientX - rect.left;
        }
        else {
            delta = event.clientY - rect.top;
        }
        // Override the cursor and store the press data.
        var style = window.getComputedStyle(handle);
        var override = phosphor_domutil_1.overrideCursor(style.cursor);
        this._pressData = { index: index, delta: delta, override: override };
    };
    /**
     * Handle the `'mousemove'` event for the split panel.
     */
    SplitPanel.prototype._evtMouseMove = function (event) {
        // Stop the event when dragging a split handle.
        event.preventDefault();
        event.stopPropagation();
        // Compute the desired offset position for the handle.
        var pos;
        var data = this._pressData;
        var layout = this.layout;
        var rect = this.node.getBoundingClientRect();
        if (layout.orientation === Orientation.Horizontal) {
            pos = event.clientX - data.delta - rect.left;
        }
        else {
            pos = event.clientY - data.delta - rect.top;
        }
        // Move the handle as close to the desired position as possible.
        layout.moveHandle(data.index, pos);
    };
    /**
     * Handle the `'mouseup'` event for the split panel.
     */
    SplitPanel.prototype._evtMouseUp = function (event) {
        // Do nothing if the left mouse button is not released.
        if (event.button !== 0) {
            return;
        }
        // Stop the event when releasing a handle.
        event.preventDefault();
        event.stopPropagation();
        // Finalize the mouse release.
        this._releaseMouse();
    };
    /**
     * Release the mouse grab for the split panel.
     */
    SplitPanel.prototype._releaseMouse = function () {
        // Bail early if no drag is in progress.
        if (!this._pressData) {
            return;
        }
        // Clear the override cursor.
        this._pressData.override.dispose();
        this._pressData = null;
        // Remove the extra document listeners.
        document.removeEventListener('mouseup', this, true);
        document.removeEventListener('mousemove', this, true);
        document.removeEventListener('keydown', this, true);
        document.removeEventListener('keyup', this, true);
        document.removeEventListener('keypress', this, true);
        document.removeEventListener('contextmenu', this, true);
    };
    return SplitPanel;
})(phosphor_widget_1.Panel);
exports.SplitPanel = SplitPanel;
/**
 * The namespace for the `SplitPanel` class statics.
 */
var SplitPanel;
(function (SplitPanel) {
    /**
     * A convenience alias of the `Horizontal` [[Orientation]].
     */
    SplitPanel.Horizontal = Orientation.Horizontal;
    /**
     * A convenience alias of the `Vertical` [[Orientation]].
     */
    SplitPanel.Vertical = Orientation.Vertical;
    /**
     * Get the split panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The split panel stretch factor for the widget.
     */
    function getStretch(widget) {
        return SplitLayout.getStretch(widget);
    }
    SplitPanel.getStretch = getStretch;
    /**
     * Set the split panel stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        SplitLayout.setStretch(widget, value);
    }
    SplitPanel.setStretch = setStretch;
})(SplitPanel = exports.SplitPanel || (exports.SplitPanel = {}));
/**
 * A layout which arranges its children into resizable sections.
 */
var SplitLayout = (function (_super) {
    __extends(SplitLayout, _super);
    function SplitLayout() {
        _super.apply(this, arguments);
    }
    Object.defineProperty(SplitLayout.prototype, "orientation", {
        /**
         * Get the layout orientation for the split layout.
         */
        get: function () {
            return SplitLayoutPrivate.orientationProperty.get(this);
        },
        /**
         * Set the layout orientation for the split layout.
         */
        set: function (value) {
            SplitLayoutPrivate.orientationProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SplitLayout.prototype, "spacing", {
        /**
         * Get the inter-element spacing for the split layout.
         */
        get: function () {
            return SplitLayoutPrivate.spacingProperty.get(this);
        },
        /**
         * Set the inter-element spacing for the split layout.
         */
        set: function (value) {
            SplitLayoutPrivate.spacingProperty.set(this, value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get the normalized sizes of the widgets in the layout.
     *
     * @returns The normalized sizes of the widgets in the layout.
     */
    SplitLayout.prototype.sizes = function () {
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        return SplitLayoutPrivate.normalize(sizers.map(function (s) { return s.size; }));
    };
    /**
     * Set the relative sizes for the child widgets in the layout.
     *
     * @param sizes - The relative sizes for the children in the layout.
     *   These values will be normalized to the available layout space.
     *
     * #### Notes
     * Extra values are ignored, too few will yield an undefined layout.
     */
    SplitLayout.prototype.setSizes = function (sizes) {
        var normed = SplitLayoutPrivate.normalize(sizes);
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        for (var i = 0, n = sizers.length; i < n; ++i) {
            var hint = Math.max(0, normed[i] || 0);
            var sizer = sizers[i];
            sizer.sizeHint = hint;
            sizer.size = hint;
        }
        SplitLayoutPrivate.pendingSizesProperty.set(this, true);
        if (this.parent)
            this.parent.update();
    };
    /**
     * Find the split handle node which contains the given target.
     *
     * @param target - The target node of interest.
     *
     * @returns An object which holds the `index` and the `handle` node
     *   which contains the specified target. If no match is found, the
     *   returned `index` will be `-1` and the `handle` will be `null`.
     */
    SplitLayout.prototype.findHandle = function (target) {
        var handleProperty = SplitLayoutPrivate.splitHandleProperty;
        for (var i = 0, n = this.childCount(); i < n; ++i) {
            var handle = handleProperty.get(this.childAt(i)).node;
            if (handle.contains(target))
                return { index: i, handle: handle };
        }
        return { index: -1, handle: null };
    };
    /**
     * Move a split handle to the specified offset position.
     *
     * @param index - The index of the handle of the interest.
     *
     * @param position - The desired offset position of the handle. This
     *   is the absolute position relative to the origin of the parent.
     *
     * #### Notes
     * This will move the specified handle as close as possible to the
     * desired position, adjusting sibling children if required. It will
     * not violate the size constraints of any child.
     */
    SplitLayout.prototype.moveHandle = function (index, position) {
        // Bail if the index is invalid.
        var widget = this.childAt(index);
        if (!widget) {
            return;
        }
        // Bail if the handle is hidden.
        var handle = SplitLayoutPrivate.splitHandleProperty.get(widget);
        if (handle.isHidden) {
            return;
        }
        // Compute the delta movement for the handle.
        var delta;
        if (this.orientation === Orientation.Horizontal) {
            delta = position - handle.node.offsetLeft;
        }
        else {
            delta = position - handle.node.offsetTop;
        }
        // Bail if there is no handle movement.
        if (delta === 0) {
            return;
        }
        // Prevent item resizing unless needed.
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        for (var _i = 0; _i < sizers.length; _i++) {
            var sizer = sizers[_i];
            if (sizer.size > 0)
                sizer.sizeHint = sizer.size;
        }
        // Adjust the sizers to reflect the movement.
        if (delta > 0) {
            SplitLayoutPrivate.growSizer(sizers, index, delta);
        }
        else {
            SplitLayoutPrivate.shrinkSizer(sizers, index, -delta);
        }
        // Update the layout of the child widgets.
        if (this.parent)
            this.parent.update();
    };
    /**
     * Initialize the children of the layout.
     *
     * #### Notes
     * This method is called automatically when the layout is installed
     * on its parent widget.
     */
    SplitLayout.prototype.initialize = function () {
        SplitLayoutPrivate.initialize(this);
        _super.prototype.initialize.call(this);
    };
    /**
     * Attach a child widget to the parent's DOM node.
     *
     * @param index - The current index of the child in the layout.
     *
     * @param child - The child widget to attach to the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.attachChild = function (index, child) {
        var handle = SplitLayoutPrivate.splitHandleProperty.get(child);
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        var average = SplitLayoutPrivate.averageSize(sizers);
        var sizer = SplitLayoutPrivate.createSizer(average);
        arrays.insert(sizers, index, sizer);
        this.parent.node.appendChild(child.node);
        this.parent.node.appendChild(handle.node);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgAfterAttach);
        this.parent.fit();
    };
    /**
     * Move a child widget in the parent's DOM node.
     *
     * @param fromIndex - The previous index of the child in the layout.
     *
     * @param toIndex - The current index of the child in the layout.
     *
     * @param child - The child widget to move in the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.moveChild = function (fromIndex, toIndex, child) {
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        arrays.move(sizers, fromIndex, toIndex);
        this.parent.fit(); // fit instead of update to show/hide handles
    };
    /**
     * Detach a child widget from the parent's DOM node.
     *
     * @param index - The previous index of the child in the layout.
     *
     * @param child - The child widget to detach from the parent.
     *
     * #### Notes
     * This is a reimplementation of the superclass method.
     */
    SplitLayout.prototype.detachChild = function (index, child) {
        var handle = SplitLayoutPrivate.splitHandleProperty.get(child);
        var sizers = SplitLayoutPrivate.sizersProperty.get(this);
        arrays.removeAt(sizers, index);
        if (this.parent.isAttached)
            phosphor_messaging_1.sendMessage(child, phosphor_widget_1.Widget.MsgBeforeDetach);
        this.parent.node.removeChild(child.node);
        this.parent.node.removeChild(handle.node);
        SplitLayoutPrivate.resetGeometry(child);
        this.parent.fit();
    };
    /**
     * A message handler invoked on an `'after-show'` message.
     */
    SplitLayout.prototype.onAfterShow = function (msg) {
        _super.prototype.onAfterShow.call(this, msg);
        this.parent.update();
    };
    /**
     * A message handler invoked on an `'after-attach'` message.
     */
    SplitLayout.prototype.onAfterAttach = function (msg) {
        _super.prototype.onAfterAttach.call(this, msg);
        this.parent.fit();
    };
    /**
     * A message handler invoked on a `'child-shown'` message.
     */
    SplitLayout.prototype.onChildShown = function (msg) {
        // IE paints before firing animation frame callbacks when toggling
        // `display: none`. This causes flicker, so IE is fit immediately.
        if (SplitLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'child-hidden'` message.
     */
    SplitLayout.prototype.onChildHidden = function (msg) {
        // IE paints before firing animation frame callbacks when toggling
        // `display: none`. This causes flicker, so IE is fit immediately.
        if (SplitLayoutPrivate.IsIE) {
            phosphor_messaging_1.sendMessage(this.parent, phosphor_widget_1.Widget.MsgFitRequest);
        }
        else {
            this.parent.fit();
        }
    };
    /**
     * A message handler invoked on a `'resize'` message.
     */
    SplitLayout.prototype.onResize = function (msg) {
        if (this.parent.isVisible) {
            SplitLayoutPrivate.update(this, msg.width, msg.height);
        }
    };
    /**
     * A message handler invoked on an `'update-request'` message.
     */
    SplitLayout.prototype.onUpdateRequest = function (msg) {
        if (this.parent.isVisible) {
            SplitLayoutPrivate.update(this, -1, -1);
        }
    };
    /**
     * A message handler invoked on a `'fit-request'` message.
     */
    SplitLayout.prototype.onFitRequest = function (msg) {
        if (this.parent.isAttached) {
            SplitLayoutPrivate.fit(this);
        }
    };
    return SplitLayout;
})(phosphor_widget_1.PanelLayout);
exports.SplitLayout = SplitLayout;
/**
 * The namespace for the `SplitLayout` class statics.
 */
var SplitLayout;
(function (SplitLayout) {
    /**
     * A convenience alias of the `Horizontal` [[Orientation]].
     */
    SplitLayout.Horizontal = Orientation.Horizontal;
    /**
     * A convenience alias of the `Vertical` [[Orientation]].
     */
    SplitLayout.Vertical = Orientation.Vertical;
    /**
     * Get the split layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @returns The split layout stretch factor for the widget.
     */
    function getStretch(widget) {
        return SplitLayoutPrivate.stretchProperty.get(widget);
    }
    SplitLayout.getStretch = getStretch;
    /**
     * Set the split layout stretch factor for the given widget.
     *
     * @param widget - The widget of interest.
     *
     * @param value - The value for the stretch factor.
     */
    function setStretch(widget, value) {
        SplitLayoutPrivate.stretchProperty.set(widget, value);
    }
    SplitLayout.setStretch = setStretch;
})(SplitLayout = exports.SplitLayout || (exports.SplitLayout = {}));
/**
 * A class which manages a handle node for a split layout.
 */
var SplitHandle = (function (_super) {
    __extends(SplitHandle, _super);
    /**
     * Construct a new split handle.
     */
    function SplitHandle() {
        _super.call(this);
        this.addClass(SPLIT_HANDLE_CLASS);
    }
    /**
     * Create the DOM node for a split handle.
     */
    SplitHandle.createNode = function () {
        var node = document.createElement('div');
        var overlay = document.createElement('div');
        overlay.className = OVERLAY_CLASS;
        node.appendChild(overlay);
        return node;
    };
    Object.defineProperty(SplitHandle.prototype, "isHidden", {
        /**
         * Test whether the handle is hidden.
         */
        get: function () {
            return this.hasClass(HIDDEN_CLASS);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Set whether the handle is hidden.
     */
    SplitHandle.prototype.setHidden = function (value) {
        this.toggleClass(HIDDEN_CLASS, value);
    };
    /**
     * Set the orientation of the handle.
     */
    SplitHandle.prototype.setOrientation = function (value) {
        this.toggleClass(HORIZONTAL_CLASS, value === Orientation.Horizontal);
        this.toggleClass(VERTICAL_CLASS, value === Orientation.Vertical);
    };
    /**
     * Set the geometry for the handle.
     */
    SplitHandle.prototype.setGeometry = function (left, top, width, height) {
        var style = this.node.style;
        style.top = top + 'px';
        style.left = left + 'px';
        style.width = width + 'px';
        style.height = height + 'px';
    };
    return SplitHandle;
})(phosphor_nodewrapper_1.NodeWrapper);
/**
 * The namespace for the `SplitLayout` class private data.
 */
var SplitLayoutPrivate;
(function (SplitLayoutPrivate) {
    /**
     * A flag indicating whether the browser is IE.
     */
    SplitLayoutPrivate.IsIE = /Trident/.test(navigator.userAgent);
    /**
     * The property descriptor for the split layout orientation.
     */
    SplitLayoutPrivate.orientationProperty = new phosphor_properties_1.Property({
        name: 'orientation',
        value: Orientation.Horizontal,
        changed: onOrientationChanged,
    });
    /**
     * The property descriptor for the split layout spacing.
     */
    SplitLayoutPrivate.spacingProperty = new phosphor_properties_1.Property({
        name: 'spacing',
        value: 3,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onSpacingChanged,
    });
    /**
     * The property descriptor for the split layout sizers.
     */
    SplitLayoutPrivate.sizersProperty = new phosphor_properties_1.Property({
        name: 'sizers',
        create: function () { return []; },
    });
    /**
     * The property descriptor for the split layout pending sizes flag.
     */
    SplitLayoutPrivate.pendingSizesProperty = new phosphor_properties_1.Property({
        name: 'pendingSizes',
        value: false,
    });
    /**
     * The property descriptor for a widget stretch factor.
     */
    SplitLayoutPrivate.stretchProperty = new phosphor_properties_1.Property({
        name: 'stretch',
        value: 0,
        coerce: function (owner, value) { return Math.max(0, value | 0); },
        changed: onChildPropertyChanged,
    });
    /**
     * The property descriptor for a widget split handle.
     */
    SplitLayoutPrivate.splitHandleProperty = new phosphor_properties_1.Property({
        name: 'splitHandle',
        create: function (owner) { return new SplitHandle(); },
    });
    /**
     * Create a new box sizer with the given size hint.
     */
    function createSizer(size) {
        var sizer = new phosphor_boxengine_1.BoxSizer();
        sizer.sizeHint = size | 0;
        return sizer;
    }
    SplitLayoutPrivate.createSizer = createSizer;
    /**
     * Compute the average size of the given box sizers.
     */
    function averageSize(sizers) {
        if (sizers.length === 0)
            return 0;
        return sizers.reduce(function (v, s) { return v + s.size; }, 0) / sizers.length;
    }
    SplitLayoutPrivate.averageSize = averageSize;
    /**
     * Normalize an array of positive values.
     */
    function normalize(values) {
        var n = values.length;
        if (n === 0) {
            return [];
        }
        var sum = 0;
        for (var i = 0; i < n; ++i) {
            sum += values[i];
        }
        var result = new Array(n);
        if (sum === 0) {
            for (var i = 0; i < n; ++i) {
                result[i] = 1 / n;
            }
        }
        else {
            for (var i = 0; i < n; ++i) {
                result[i] = values[i] / sum;
            }
        }
        return result;
    }
    SplitLayoutPrivate.normalize = normalize;
    /**
     * Initialize the private layout state.
     *
     * #### Notes
     * This should be called during layout initialization.
     */
    function initialize(layout) {
        updateParentOrientation(layout);
    }
    SplitLayoutPrivate.initialize = initialize;
    /**
     * Reset the layout geometry for the given child widget.
     */
    function resetGeometry(widget) {
        var rect = rectProperty.get(widget);
        var style = widget.node.style;
        rect.top = NaN;
        rect.left = NaN;
        rect.width = NaN;
        rect.height = NaN;
        style.top = '';
        style.left = '';
        style.width = '';
        style.height = '';
    }
    SplitLayoutPrivate.resetGeometry = resetGeometry;
    /**
     * Fit the layout to the total size required by the child widgets.
     */
    function fit(layout) {
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Update the handles and track the visible widget count.
        var visibleCount = 0;
        var orientation = layout.orientation;
        var lastVisibleHandle = null;
        for (var i = 0, n = layout.childCount(); i < n; ++i) {
            var widget = layout.childAt(i);
            var handle = SplitLayoutPrivate.splitHandleProperty.get(widget);
            handle.setHidden(widget.isHidden);
            handle.setOrientation(orientation);
            if (!widget.isHidden) {
                lastVisibleHandle = handle;
                visibleCount++;
            }
        }
        // Hide the last visible handle and update the fixed spacing.
        if (lastVisibleHandle)
            lastVisibleHandle.setHidden(true);
        var fixedSpace = layout.spacing * Math.max(0, visibleCount - 1);
        fixedSpaceProperty.set(layout, fixedSpace);
        // Update the sizers and compute the new size limits.
        var minW = 0;
        var minH = 0;
        var maxW = Infinity;
        var maxH = Infinity;
        var sizers = SplitLayoutPrivate.sizersProperty.get(layout);
        if (orientation === Orientation.Horizontal) {
            minW = fixedSpace;
            maxW = visibleCount > 0 ? minW : maxW;
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                var sizer = sizers[i];
                if (sizer.size > 0) {
                    sizer.sizeHint = sizer.size;
                }
                if (widget.isHidden) {
                    sizer.minSize = 0;
                    sizer.maxSize = 0;
                    continue;
                }
                var limits = phosphor_domutil_1.sizeLimits(widget.node);
                sizer.stretch = SplitLayoutPrivate.stretchProperty.get(widget);
                sizer.minSize = limits.minWidth;
                sizer.maxSize = limits.maxWidth;
                minW += limits.minWidth;
                maxW += limits.maxWidth;
                minH = Math.max(minH, limits.minHeight);
                maxH = Math.min(maxH, limits.maxHeight);
            }
        }
        else {
            minH = fixedSpace;
            maxH = visibleCount > 0 ? minH : maxH;
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                var sizer = sizers[i];
                if (sizer.size > 0) {
                    sizer.sizeHint = sizer.size;
                }
                if (widget.isHidden) {
                    sizer.minSize = 0;
                    sizer.maxSize = 0;
                    continue;
                }
                var limits = phosphor_domutil_1.sizeLimits(widget.node);
                sizer.stretch = SplitLayoutPrivate.stretchProperty.get(widget);
                sizer.minSize = limits.minHeight;
                sizer.maxSize = limits.maxHeight;
                minH += limits.minHeight;
                maxH += limits.maxHeight;
                minW = Math.max(minW, limits.minWidth);
                maxW = Math.min(maxW, limits.maxWidth);
            }
        }
        // Update the box sizing and add it to the size constraints.
        var box = phosphor_domutil_1.boxSizing(parent.node);
        boxSizingProperty.set(parent, box);
        minW += box.horizontalSum;
        minH += box.verticalSum;
        maxW += box.horizontalSum;
        maxH += box.verticalSum;
        // Update the panel's size constraints.
        var style = parent.node.style;
        style.minWidth = minW + 'px';
        style.minHeight = minH + 'px';
        style.maxWidth = maxW === Infinity ? 'none' : maxW + 'px';
        style.maxHeight = maxH === Infinity ? 'none' : maxH + 'px';
        // Notify the ancestor that it should fit immediately.
        if (parent.parent)
            phosphor_messaging_1.sendMessage(parent.parent, phosphor_widget_1.Widget.MsgFitRequest);
        // Notify the parent that it should update immediately.
        phosphor_messaging_1.sendMessage(parent, phosphor_widget_1.Widget.MsgUpdateRequest);
    }
    SplitLayoutPrivate.fit = fit;
    /**
     * Layout the children using the given offset width and height.
     *
     * If the dimensions are unknown, they should be specified as `-1`.
     */
    function update(layout, offsetWidth, offsetHeight) {
        // Bail early if their are no children to layout.
        if (layout.childCount() === 0) {
            return;
        }
        // Bail early if there is no parent.
        var parent = layout.parent;
        if (!parent) {
            return;
        }
        // Measure the parent if the offset dimensions are unknown.
        if (offsetWidth < 0) {
            offsetWidth = parent.node.offsetWidth;
        }
        if (offsetHeight < 0) {
            offsetHeight = parent.node.offsetHeight;
        }
        // Lookup the layout data.
        var spacing = layout.spacing;
        var orient = layout.orientation;
        var box = boxSizingProperty.get(parent);
        var sizers = SplitLayoutPrivate.sizersProperty.get(layout);
        var fixedSpace = fixedSpaceProperty.get(layout);
        // Compute the actual layout bounds adjusted for border and padding.
        var top = box.paddingTop;
        var left = box.paddingLeft;
        var width = offsetWidth - box.horizontalSum;
        var height = offsetHeight - box.verticalSum;
        // Compute the adjusted main layout space.
        var mainSpace;
        if (orient === Orientation.Horizontal) {
            mainSpace = Math.max(0, width - fixedSpace);
        }
        else {
            mainSpace = Math.max(0, height - fixedSpace);
        }
        // Update the sizer hints if there is a pending set sizes.
        if (SplitLayoutPrivate.pendingSizesProperty.get(layout)) {
            for (var i = 0, n = sizers.length; i < n; ++i) {
                sizers[i].sizeHint *= mainSpace;
            }
            SplitLayoutPrivate.pendingSizesProperty.set(layout, false);
        }
        // Distribute the available layout space.
        phosphor_boxengine_1.boxCalc(sizers, mainSpace);
        // Layout the children.
        if (orient === Orientation.Horizontal) {
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                var handle = SplitLayoutPrivate.splitHandleProperty.get(widget);
                setGeometry(widget, left, top, size, height);
                handle.setGeometry(left + size, top, spacing, height);
                left += size + spacing;
            }
        }
        else {
            for (var i = 0, n = layout.childCount(); i < n; ++i) {
                var widget = layout.childAt(i);
                if (widget.isHidden) {
                    continue;
                }
                var size = sizers[i].size;
                var handle = SplitLayoutPrivate.splitHandleProperty.get(widget);
                setGeometry(widget, left, top, width, size);
                handle.setGeometry(left, top + size, width, spacing);
                top += size + spacing;
            }
        }
    }
    SplitLayoutPrivate.update = update;
    /**
     * Grow a sizer to the right by a positive delta and adjust neighbors.
     */
    function growSizer(sizers, index, delta) {
        var growLimit = 0;
        for (var i = 0; i <= index; ++i) {
            var sizer = sizers[i];
            growLimit += sizer.maxSize - sizer.size;
        }
        var shrinkLimit = 0;
        for (var i = index + 1, n = sizers.length; i < n; ++i) {
            var sizer = sizers[i];
            shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        var grow = delta;
        for (var i = index; i >= 0 && grow > 0; --i) {
            var sizer = sizers[i];
            var limit = sizer.maxSize - sizer.size;
            if (limit >= grow) {
                sizer.sizeHint = sizer.size + grow;
                grow = 0;
            }
            else {
                sizer.sizeHint = sizer.size + limit;
                grow -= limit;
            }
        }
        var shrink = delta;
        for (var i = index + 1, n = sizers.length; i < n && shrink > 0; ++i) {
            var sizer = sizers[i];
            var limit = sizer.size - sizer.minSize;
            if (limit >= shrink) {
                sizer.sizeHint = sizer.size - shrink;
                shrink = 0;
            }
            else {
                sizer.sizeHint = sizer.size - limit;
                shrink -= limit;
            }
        }
    }
    SplitLayoutPrivate.growSizer = growSizer;
    /**
     * Shrink a sizer to the left by a positive delta and adjust neighbors.
     */
    function shrinkSizer(sizers, index, delta) {
        var growLimit = 0;
        for (var i = index + 1, n = sizers.length; i < n; ++i) {
            var sizer = sizers[i];
            growLimit += sizer.maxSize - sizer.size;
        }
        var shrinkLimit = 0;
        for (var i = 0; i <= index; ++i) {
            var sizer = sizers[i];
            shrinkLimit += sizer.size - sizer.minSize;
        }
        delta = Math.min(delta, growLimit, shrinkLimit);
        var grow = delta;
        for (var i = index + 1, n = sizers.length; i < n && grow > 0; ++i) {
            var sizer = sizers[i];
            var limit = sizer.maxSize - sizer.size;
            if (limit >= grow) {
                sizer.sizeHint = sizer.size + grow;
                grow = 0;
            }
            else {
                sizer.sizeHint = sizer.size + limit;
                grow -= limit;
            }
        }
        var shrink = delta;
        for (var i = index; i >= 0 && shrink > 0; --i) {
            var sizer = sizers[i];
            var limit = sizer.size - sizer.minSize;
            if (limit >= shrink) {
                sizer.sizeHint = sizer.size - shrink;
                shrink = 0;
            }
            else {
                sizer.sizeHint = sizer.size - limit;
                shrink -= limit;
            }
        }
    }
    SplitLayoutPrivate.shrinkSizer = shrinkSizer;
    /**
     * A property descriptor for a widget offset rect.
     */
    var rectProperty = new phosphor_properties_1.Property({
        name: 'rect',
        create: function () { return ({ top: NaN, left: NaN, width: NaN, height: NaN }); },
    });
    /**
     * A property descriptor for the box sizing of a widget.
     */
    var boxSizingProperty = new phosphor_properties_1.Property({
        name: 'boxSizing',
        create: function (owner) { return phosphor_domutil_1.boxSizing(owner.node); },
    });
    /**
     * A property descriptor for the box layout fixed spacing.
     */
    var fixedSpaceProperty = new phosphor_properties_1.Property({
        name: 'fixedSpace',
        value: 0,
    });
    /**
     * The change handler for the split layout orientation.
     */
    function onOrientationChanged(layout) {
        updateParentOrientation(layout);
        if (layout.parent)
            layout.parent.fit();
    }
    /**
     * The change handler for the split layout spacing.
     */
    function onSpacingChanged(layout) {
        if (layout.parent)
            layout.parent.fit();
    }
    /**
     * The change handler for the attached child properties.
     */
    function onChildPropertyChanged(child) {
        var parent = child.parent;
        var layout = parent && parent.layout;
        if (layout instanceof SplitLayout)
            parent.fit();
    }
    /**
     * Update the CSS orientation class on the layout parent.
     */
    function updateParentOrientation(layout) {
        if (!layout.parent)
            return;
        var parent = layout.parent;
        var orient = layout.orientation;
        parent.toggleClass(HORIZONTAL_CLASS, orient === Orientation.Horizontal);
        parent.toggleClass(VERTICAL_CLASS, orient === Orientation.Vertical);
    }
    /**
     * Set the offset geometry for the given widget.
     *
     * A resize message will be dispatched to the widget if appropriate.
     */
    function setGeometry(widget, left, top, width, height) {
        var resized = false;
        var style = widget.node.style;
        var rect = rectProperty.get(widget);
        if (rect.top !== top) {
            rect.top = top;
            style.top = top + 'px';
        }
        if (rect.left !== left) {
            rect.left = left;
            style.left = left + 'px';
        }
        if (rect.width !== width) {
            resized = true;
            rect.width = width;
            style.width = width + 'px';
        }
        if (rect.height !== height) {
            resized = true;
            rect.height = height;
            style.height = height + 'px';
        }
        if (resized) {
            phosphor_messaging_1.sendMessage(widget, new phosphor_widget_1.ResizeMessage(width, height));
        }
    }
})(SplitLayoutPrivate || (SplitLayoutPrivate = {}));
