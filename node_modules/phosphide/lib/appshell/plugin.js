/*-----------------------------------------------------------------------------
| Copyright (c) 2014-2015, PhosphorJS Contributors
|
| Distributed under the terms of the BSD 3-Clause License.
|
| The full license is in the file LICENSE, distributed with this software.
|----------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var arrays = require('phosphor-arrays');
var phosphor_boxpanel_1 = require('phosphor-boxpanel');
var phosphor_dockpanel_1 = require('phosphor-dockpanel');
var phosphor_splitpanel_1 = require('phosphor-splitpanel');
var phosphor_stackedpanel_1 = require('phosphor-stackedpanel');
var phosphor_widget_1 = require('phosphor-widget');
var index_1 = require('./index');
var sidebar_1 = require('./sidebar');
require('./plugin.css');
// TODO - need better solution for storing these class names
/**
 * The class name added to AppShell instances.
 */
var APP_SHELL_CLASS = 'p-AppShell';
/**
 * Register the plugin contributions.
 *
 * @param container - The di container for type registration.
 *
 * #### Notes
 * This is called automatically when the plugin is loaded.
 */
function register(container) {
    container.register(index_1.IAppShell, AppShell);
}
exports.register = register;
/**
 * A concrete implementation of `IAppShell`.
 */
var AppShell = (function (_super) {
    __extends(AppShell, _super);
    /**
     * Construct a new application shell.
     */
    function AppShell() {
        _super.call(this);
        this.addClass(APP_SHELL_CLASS);
        var topPanel = new phosphor_widget_1.Panel();
        var hboxPanel = new phosphor_boxpanel_1.BoxPanel();
        var dockPanel = new phosphor_dockpanel_1.DockPanel();
        var hsplitPanel = new phosphor_splitpanel_1.SplitPanel();
        var leftHandler = new SideBarHandler();
        var rightHandler = new SideBarHandler();
        var rootLayout = new phosphor_boxpanel_1.BoxLayout();
        this._topPanel = topPanel;
        this._hboxPanel = hboxPanel;
        this._dockPanel = dockPanel;
        this._hsplitPanel = hsplitPanel;
        this._leftHandler = leftHandler;
        this._rightHandler = rightHandler;
        // TODO fix these
        hsplitPanel.id = 'p-main-split-panel';
        leftHandler.sideBar.addClass('p-mod-left');
        rightHandler.sideBar.addClass('p-mod-right');
        leftHandler.stackedPanel.id = 'p-left-stack';
        rightHandler.stackedPanel.id = 'p-right-stack';
        dockPanel.id = 'p-main-dock-panel';
        hsplitPanel.orientation = phosphor_splitpanel_1.SplitPanel.Horizontal;
        hsplitPanel.spacing = 1; // TODO make this configurable?
        phosphor_splitpanel_1.SplitPanel.setStretch(leftHandler.stackedPanel, 0);
        phosphor_splitpanel_1.SplitPanel.setStretch(dockPanel, 1);
        phosphor_splitpanel_1.SplitPanel.setStretch(rightHandler.stackedPanel, 0);
        hsplitPanel.addChild(leftHandler.stackedPanel);
        hsplitPanel.addChild(dockPanel);
        hsplitPanel.addChild(rightHandler.stackedPanel);
        hboxPanel.direction = phosphor_boxpanel_1.BoxPanel.LeftToRight;
        hboxPanel.spacing = 0; // TODO make this configurable?
        phosphor_boxpanel_1.BoxPanel.setStretch(leftHandler.sideBar, 0);
        phosphor_boxpanel_1.BoxPanel.setStretch(hsplitPanel, 1);
        phosphor_boxpanel_1.BoxPanel.setStretch(rightHandler.sideBar, 0);
        hboxPanel.addChild(leftHandler.sideBar);
        hboxPanel.addChild(hsplitPanel);
        hboxPanel.addChild(rightHandler.sideBar);
        rootLayout.direction = phosphor_boxpanel_1.BoxLayout.TopToBottom;
        rootLayout.spacing = 0; // TODO make this configurable?
        phosphor_boxpanel_1.BoxLayout.setStretch(topPanel, 0);
        phosphor_boxpanel_1.BoxLayout.setStretch(hboxPanel, 1);
        rootLayout.addChild(topPanel);
        rootLayout.addChild(hboxPanel);
        this.layout = rootLayout;
    }
    /**
     * Create a new application shell instance.
     */
    AppShell.create = function () {
        var shell = new AppShell();
        var update = function () { shell.update(); };
        window.addEventListener('resize', update);
        shell.attach(document.body);
        return shell;
    };
    /**
     * Add a widget to the top content area.
     */
    AppShell.prototype.addToTopArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        // TODO
    };
    /**
     * Add a widget to the left content area.
     */
    AppShell.prototype.addToLeftArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        var rank = 'rank' in options ? options.rank : 100;
        this._leftHandler.addWidget(widget, rank);
    };
    /**
     * Add a widget to the right content area.
     */
    AppShell.prototype.addToRightArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        var rank = 'rank' in options ? options.rank : 100;
        this._rightHandler.addWidget(widget, rank);
    };
    /**
     * Add a widget to the main content area.
     */
    AppShell.prototype.addToMainArea = function (widget, options) {
        if (options === void 0) { options = {}; }
        // TODO
        this._dockPanel.insertTabAfter(widget);
    };
    /**
     * The dependencies required by the application shell.
     */
    AppShell.requires = [];
    return AppShell;
})(phosphor_widget_1.Widget);
/**
 * A class which manages a side bar and related stacked panel.
 */
var SideBarHandler = (function () {
    /**
     * Construct a new side bar handler.
     */
    function SideBarHandler() {
        this._items = [];
        this._sideBar = new sidebar_1.SideBar();
        this._stackedPanel = new phosphor_stackedpanel_1.StackedPanel();
        this._sideBar.hide();
        this._stackedPanel.hide();
        this._sideBar.currentChanged.connect(this._onCurrentChanged, this);
        this._stackedPanel.widgetRemoved.connect(this._onWidgetRemoved, this);
    }
    /**
     * A less-than comparison function for side bar rank items.
     */
    SideBarHandler.itemCmp = function (first, second) {
        return first.rank < second.rank;
    };
    Object.defineProperty(SideBarHandler.prototype, "sideBar", {
        /**
         * Get the side bar managed by the handler.
         */
        get: function () {
            return this._sideBar;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SideBarHandler.prototype, "stackedPanel", {
        /**
         * Get the stacked panel managed by the handler
         */
        get: function () {
            return this._stackedPanel;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Add a widget and its title to the stacked panel and side bar.
     *
     * If the widget is already added, it will be moved.
     */
    SideBarHandler.prototype.addWidget = function (widget, rank) {
        widget.parent = null;
        var item = { widget: widget, rank: rank };
        var index = this._findInsertIndex(item);
        arrays.insert(this._items, index, item);
        this._stackedPanel.insertChild(index, widget);
        this._sideBar.insertTitle(index, widget.title);
        this._refreshVisibility();
    };
    /**
     * Find the insertion index for a rank item.
     */
    SideBarHandler.prototype._findInsertIndex = function (item) {
        return arrays.upperBound(this._items, item, SideBarHandler.itemCmp);
    };
    /**
     * Find the index of the item with the given widget, or `-1`.
     */
    SideBarHandler.prototype._findWidgetIndex = function (widget) {
        return arrays.findIndex(this._items, function (item) { return item.widget === widget; });
    };
    /**
     * Find the widget which owns the given title, or `null`.
     */
    SideBarHandler.prototype._findTitleWidget = function (title) {
        var item = arrays.find(this._items, function (item) { return item.widget.title === title; });
        return item ? item.widget : null;
    };
    /**
     * Refresh the visibility of the side bar and stacked panel.
     */
    SideBarHandler.prototype._refreshVisibility = function () {
        this._sideBar.setHidden(this._sideBar.titleCount() === 0);
        this._stackedPanel.setHidden(this._stackedPanel.currentWidget === null);
    };
    /**
     * Handle the `currentChanged` signal from the sidebar.
     */
    SideBarHandler.prototype._onCurrentChanged = function (sender, args) {
        this._stackedPanel.currentWidget = this._findTitleWidget(args.newValue);
        this._refreshVisibility();
    };
    /*
     * Handle the `widgetRemoved` signal from the stacked panel.
     */
    SideBarHandler.prototype._onWidgetRemoved = function (sender, widget) {
        arrays.removeAt(this._items, this._findWidgetIndex(widget));
        this._sideBar.removeTitle(widget.title);
        this._refreshVisibility();
    };
    return SideBarHandler;
})();
